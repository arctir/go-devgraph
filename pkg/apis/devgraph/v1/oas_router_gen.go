// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

func (s *Server) cutPrefix(path string) (string, bool) {
	prefix := s.cfg.Prefix
	if prefix == "" {
		return path, true
	}
	if !strings.HasPrefix(path, prefix) {
		// Prefix doesn't match.
		return "", false
	}
	// Cut prefix from the path.
	return strings.TrimPrefix(path, prefix), true
}

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}

	elem, ok := s.cutPrefix(elem)
	if !ok || len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [5]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/v1/"

			if l := len("/api/v1/"); len(elem) >= l && elem[0:l] == "/api/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "chat"

				if l := len("chat"); len(elem) >= l && elem[0:l] == "chat" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/suggestions"

					if l := len("/suggestions"); len(elem) >= l && elem[0:l] == "/suggestions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListChatSuggestionsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateChatSuggestionRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "suggestion_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteChatSuggestionRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}

					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteChatsBulkRequest([0]string{}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetChatsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateChatRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}
					switch elem[0] {
					case 't': // Prefix: "title"
						origElem := elem
						if l := len("title"); len(elem) >= l && elem[0:l] == "title" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "POST":
								s.handleCreateChatTitleRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}

						elem = origElem
					}
					// Param: "chat_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteChatRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetChatRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdateChatRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PUT")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/messages"

						if l := len("/messages"); len(elem) >= l && elem[0:l] == "/messages" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetChatMessagesRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handlePostChatMessagesRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}

					}

				}

			case 'd': // Prefix: "discovery/"

				if l := len("discovery/"); len(elem) >= l && elem[0:l] == "discovery/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "configured-providers"

					if l := len("configured-providers"); len(elem) >= l && elem[0:l] == "configured-providers" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListConfiguredProvidersRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateConfiguredProviderRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteConfiguredProviderRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetConfiguredProviderRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateConfiguredProviderRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}

					}

				case 'i': // Prefix: "images"

					if l := len("images"); len(elem) >= l && elem[0:l] == "images" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleListDiscoveryImagesRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 'p': // Prefix: "providers"

					if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDiscoveryProvidersRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/config-schema"

							if l := len("/config-schema"); len(elem) >= l && elem[0:l] == "/config-schema" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetDiscoveryProviderConfigSchemaRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'v': // Prefix: "versions"

					if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetAllProviderVersionsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "deprecated"
							origElem := elem
							if l := len("deprecated"); len(elem) >= l && elem[0:l] == "deprecated" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetDeprecatedProviderConfigsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						case 'm': // Prefix: "migrate-all"
							origElem := elem
							if l := len("migrate-all"); len(elem) >= l && elem[0:l] == "migrate-all" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleMigrateAllDeprecatedConfigsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						}
						// Param: "provider_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/migrate"

							if l := len("/migrate"); len(elem) >= l && elem[0:l] == "/migrate" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleMigrateProviderConfigRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

						}

					}

				}

			case 'e': // Prefix: "en"

				if l := len("en"); len(elem) >= l && elem[0:l] == "en" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 't': // Prefix: "tit"

					if l := len("tit"); len(elem) >= l && elem[0:l] == "tit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "ies/"

						if l := len("ies/"); len(elem) >= l && elem[0:l] == "ies/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetEntitiesRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case 'b': // Prefix: "bulk"
							origElem := elem
							if l := len("bulk"); len(elem) >= l && elem[0:l] == "bulk" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleCreateEntitiesBulkRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}

							elem = origElem
						case 'd': // Prefix: "definitions"
							origElem := elem
							if l := len("definitions"); len(elem) >= l && elem[0:l] == "definitions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetEntityDefinitionsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateEntityDefinitionRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "definition_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteEntityDefinitionRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

							}

							elem = origElem
						case 'o': // Prefix: "orphans"
							origElem := elem
							if l := len("orphans"); len(elem) >= l && elem[0:l] == "orphans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleCleanupOrphanedEntitiesRequest([0]string{}, elemIsEscaped, w, r)
								case "GET":
									s.handleListOrphanedEntitiesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET")
								}

								return
							}

							elem = origElem
						case 'r': // Prefix: "relations"
							origElem := elem
							if l := len("relations"); len(elem) >= l && elem[0:l] == "relations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteEntityRelationRequest([0]string{}, elemIsEscaped, w, r)
								case "GET":
									s.handleListEntityRelationsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateEntityRelationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/bulk"

								if l := len("/bulk"); len(elem) >= l && elem[0:l] == "/bulk" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleCreateEntityRelationsBulkRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

							}

							elem = origElem
						case 'u': // Prefix: "uid/"
							origElem := elem
							if l := len("uid/"); len(elem) >= l && elem[0:l] == "uid/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "batch"
								origElem := elem
								if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleGetEntitiesByUIDBatchRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}

								elem = origElem
							}
							// Param: "uid"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetEntityByUIDRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

							elem = origElem
						}
						// Param: "group"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "version"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "namespace/"
									origElem := elem
									if l := len("namespace/"); len(elem) >= l && elem[0:l] == "namespace/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "namespace"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "plural"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[3] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleCreateEntityRequest([4]string{
													args[0],
													args[1],
													args[2],
													args[3],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

									}

									elem = origElem
								}
								// Param: "kind"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "namespace"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[3] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "name"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[4] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "DELETE":
												s.handleDeleteEntityRequest([5]string{
													args[0],
													args[1],
													args[2],
													args[3],
													args[4],
												}, elemIsEscaped, w, r)
											case "GET":
												s.handleGetEntityRequest([5]string{
													args[0],
													args[1],
													args[2],
													args[3],
													args[4],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "DELETE,GET")
											}

											return
										}

									}

								}

							}

						}

					case 'l': // Prefix: "lements"

						if l := len("lements"); len(elem) >= l && elem[0:l] == "lements" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetEntitlementsRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/check/"

							if l := len("/check/"); len(elem) >= l && elem[0:l] == "/check/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "entitlement_type"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleCheckEntitlementRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'v': // Prefix: "vironments"

					if l := len("vironments"); len(elem) >= l && elem[0:l] == "vironments" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetEnvironmentsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateEnvironmentRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "environment_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteEnvironmentRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "discovery-settings"

								if l := len("discovery-settings"); len(elem) >= l && elem[0:l] == "discovery-settings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetEnvironmentDiscoverySettingsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PATCH":
										s.handleUpdateEnvironmentDiscoverySettingsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,PATCH")
									}

									return
								}

							case 's': // Prefix: "status"

								if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetEnvironmentStatusRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							case 'u': // Prefix: "users"

								if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListEnvironmentUsersRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateEnvironmentUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "bulk-invite"
										origElem := elem
										if l := len("bulk-invite"); len(elem) >= l && elem[0:l] == "bulk-invite" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "POST":
												s.handleBulkInviteEnvironmentUsersRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "POST")
											}

											return
										}

										elem = origElem
									case 'i': // Prefix: "invit"
										origElem := elem
										if l := len("invit"); len(elem) >= l && elem[0:l] == "invit" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ations/"

											if l := len("ations/"); len(elem) >= l && elem[0:l] == "ations/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "DELETE":
													s.handleDeleteEnvironmentInvitationRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "DELETE")
												}

												return
											}

										case 'e': // Prefix: "e"

											if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "POST":
													s.handleInviteEnvironmentUserRequest([1]string{
														args[0],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "POST")
												}

												return
											}

										}

										elem = origElem
									case 'p': // Prefix: "pending"
										origElem := elem
										if l := len("pending"); len(elem) >= l && elem[0:l] == "pending" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetPendingInvitationsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

										elem = origElem
									}
									// Param: "user_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteEnvironmentUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetEnvironmentUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleUpdateEnvironmentUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}

								}

							}

						}

					}

				}

			case 'm': // Prefix: "m"

				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cp/"

					if l := len("cp/"); len(elem) >= l && elem[0:l] == "cp/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "en"

						if l := len("en"); len(elem) >= l && elem[0:l] == "en" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "dpoints"

							if l := len("dpoints"); len(elem) >= l && elem[0:l] == "dpoints" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetMcpendpointsRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateMcpendpointRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "mcpendpoint_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteMcpendpointRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetMcpendpointRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateMcpendpointRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "entity-types"

										if l := len("entity-types"); len(elem) >= l && elem[0:l] == "entity-types" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetMcpEndpointEntityTypesRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									case 't': // Prefix: "tools"

										if l := len("tools"); len(elem) >= l && elem[0:l] == "tools" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleListMcpendpointToolsRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}

									}

								}

							}

						case 't': // Prefix: "tity-definitions/"

							if l := len("tity-definitions/"); len(elem) >= l && elem[0:l] == "tity-definitions/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "entity_definition_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/tools"

								if l := len("/tools"); len(elem) >= l && elem[0:l] == "/tools" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetEntityToolsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}

							}

						}

					case 't': // Prefix: "tool"

						if l := len("tool"); len(elem) >= l && elem[0:l] == "tool" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-associations"

							if l := len("-associations"); len(elem) >= l && elem[0:l] == "-associations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleCreateMcpToolAssociationRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "association_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteMcpToolAssociationRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListAllMcpToolsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}

						}

					}

				case 'o': // Prefix: "odels"

					if l := len("odels"); len(elem) >= l && elem[0:l] == "odels" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleGetModelsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateModelRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "providers"
							origElem := elem
							if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetModelprovidersRequest([0]string{}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateModelproviderRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "provider_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteModelproviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "GET":
										s.handleGetModelproviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "PUT":
										s.handleUpdateModelproviderRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE,GET,PUT")
									}

									return
								}

							}

							elem = origElem
						}
						// Param: "model_name"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteModelRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetModelRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateModelRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}

					}

				}

			case 'o': // Prefix: "oauth/"

				if l := len("oauth/"); len(elem) >= l && elem[0:l] == "oauth/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "authorize"

					if l := len("authorize"); len(elem) >= l && elem[0:l] == "authorize" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "POST":
							s.handleGetOAuthAuthorizationURLRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}

				case 'o': // Prefix: "oidc-config"

					if l := len("oidc-config"); len(elem) >= l && elem[0:l] == "oidc-config" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetOidcConfigurationRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}

				case 's': // Prefix: "services"

					if l := len("services"); len(elem) >= l && elem[0:l] == "services" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListOAuthServicesRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateOAuthServiceRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "service_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteOAuthServiceRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetOAuthServiceRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateOAuthServiceRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}

					}

				case 't': // Prefix: "token"

					if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "POST":
							s.handleExchangeOAuthTokenRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}
					switch elem[0] {
					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListOAuthTokensRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service_name"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleRevokeOAuthTokenRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}

						}

					}

				}

			case 'p': // Prefix: "prompts"

				if l := len("prompts"); len(elem) >= l && elem[0:l] == "prompts" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListPromptsRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreatePromptRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "system-default"
						origElem := elem
						if l := len("system-default"); len(elem) >= l && elem[0:l] == "system-default" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetSystemDefaultPromptRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}

						elem = origElem
					}
					// Param: "prompt_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeletePromptRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetPromptRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdatePromptRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PUT")
						}

						return
					}

				}

			case 'r': // Prefix: "renderers/allowlist"

				if l := len("renderers/allowlist"); len(elem) >= l && elem[0:l] == "renderers/allowlist" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetRendererAllowlistAPIV1RenderersAllowlistGetRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 's': // Prefix: "subscriptions"

				if l := len("subscriptions"); len(elem) >= l && elem[0:l] == "subscriptions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetSubscriptionsRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}

			case 't': // Prefix: "tokens"

				if l := len("tokens"); len(elem) >= l && elem[0:l] == "tokens" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleGetTokensRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreateTokenRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "token_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteTokenRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdateTokenRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,PUT")
						}

						return
					}

				}

			}

		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name           string
	summary        string
	operationID    string
	operationGroup string
	pathPattern    string
	count          int
	args           [5]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// Summary returns OpenAPI summary.
func (r Route) Summary() string {
	return r.summary
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// OperationGroup returns the x-ogen-operation-group value.
func (r Route) OperationGroup() string {
	return r.operationGroup
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	elem, ok := s.cutPrefix(elem)
	if !ok {
		return r, false
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/api/v1/"

			if l := len("/api/v1/"); len(elem) >= l && elem[0:l] == "/api/v1/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'c': // Prefix: "chat"

				if l := len("chat"); len(elem) >= l && elem[0:l] == "chat" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case '/': // Prefix: "/suggestions"

					if l := len("/suggestions"); len(elem) >= l && elem[0:l] == "/suggestions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListChatSuggestionsOperation
							r.summary = "List Chat Suggestions"
							r.operationID = "list_chat_suggestions"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chat/suggestions"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateChatSuggestionOperation
							r.summary = "Create Chat Suggestion"
							r.operationID = "create_chat_suggestion"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chat/suggestions"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "suggestion_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = DeleteChatSuggestionOperation
								r.summary = "Delete Chat Suggestion"
								r.operationID = "delete_chat_suggestion"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/chat/suggestions/{suggestion_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				case 's': // Prefix: "s/"

					if l := len("s/"); len(elem) >= l && elem[0:l] == "s/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = DeleteChatsBulkOperation
							r.summary = "Delete Chats Bulk"
							r.operationID = "delete_chats_bulk"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/"
							r.args = args
							r.count = 0
							return r, true
						case "GET":
							r.name = GetChatsOperation
							r.summary = "Get Chats"
							r.operationID = "get_chats"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateChatOperation
							r.summary = "Create Chat"
							r.operationID = "create_chat"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case 't': // Prefix: "title"
						origElem := elem
						if l := len("title"); len(elem) >= l && elem[0:l] == "title" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "POST":
								r.name = CreateChatTitleOperation
								r.summary = "Post Chat Title"
								r.operationID = "create_chat_title"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/chats/title"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}
					// Param: "chat_id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = DeleteChatOperation
							r.summary = "Delete Chat"
							r.operationID = "delete_chat"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/{chat_id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = GetChatOperation
							r.summary = "Get Chat"
							r.operationID = "get_chat"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/{chat_id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = UpdateChatOperation
							r.summary = "Update Chat"
							r.operationID = "update_chat"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/chats/{chat_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/messages"

						if l := len("/messages"); len(elem) >= l && elem[0:l] == "/messages" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = GetChatMessagesOperation
								r.summary = "Get Chat Messages"
								r.operationID = "get_chat_messages"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/chats/{chat_id}/messages"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = PostChatMessagesOperation
								r.summary = "Post Chat Messages"
								r.operationID = "post_chat_messages"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/chats/{chat_id}/messages"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'd': // Prefix: "discovery/"

				if l := len("discovery/"); len(elem) >= l && elem[0:l] == "discovery/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "configured-providers"

					if l := len("configured-providers"); len(elem) >= l && elem[0:l] == "configured-providers" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListConfiguredProvidersOperation
							r.summary = "List Configured Providers"
							r.operationID = "list_configured_providers"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/discovery/configured-providers"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateConfiguredProviderOperation
							r.summary = "Create Configured Provider"
							r.operationID = "create_configured_provider"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/discovery/configured-providers"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = DeleteConfiguredProviderOperation
								r.summary = "Delete Configured Provider"
								r.operationID = "delete_configured_provider"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/discovery/configured-providers/{provider_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetConfiguredProviderOperation
								r.summary = "Get Configured Provider"
								r.operationID = "get_configured_provider"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/discovery/configured-providers/{provider_id}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = UpdateConfiguredProviderOperation
								r.summary = "Update Configured Provider"
								r.operationID = "update_configured_provider"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/discovery/configured-providers/{provider_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				case 'i': // Prefix: "images"

					if l := len("images"); len(elem) >= l && elem[0:l] == "images" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = ListDiscoveryImagesOperation
							r.summary = "List Discovery Images"
							r.operationID = "list_discovery_images"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/discovery/images"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'p': // Prefix: "providers"

					if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListDiscoveryProvidersOperation
							r.summary = "List Discovery Providers"
							r.operationID = "list_discovery_providers"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/discovery/providers"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "provider_type"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/config-schema"

							if l := len("/config-schema"); len(elem) >= l && elem[0:l] == "/config-schema" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetDiscoveryProviderConfigSchemaOperation
									r.summary = "Get Discovery Provider Config Schema"
									r.operationID = "get_discovery_provider_config_schema"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/discovery/providers/{provider_type}/config-schema"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'v': // Prefix: "versions"

					if l := len("versions"); len(elem) >= l && elem[0:l] == "versions" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GetAllProviderVersionsOperation
							r.summary = "Get All Provider Versions"
							r.operationID = "get_all_provider_versions"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/discovery/versions"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "deprecated"
							origElem := elem
							if l := len("deprecated"); len(elem) >= l && elem[0:l] == "deprecated" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetDeprecatedProviderConfigsOperation
									r.summary = "Get Deprecated Provider Configs"
									r.operationID = "get_deprecated_provider_configs"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/discovery/versions/deprecated"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'm': // Prefix: "migrate-all"
							origElem := elem
							if l := len("migrate-all"); len(elem) >= l && elem[0:l] == "migrate-all" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = MigrateAllDeprecatedConfigsOperation
									r.summary = "Migrate All Deprecated Configs"
									r.operationID = "migrate_all_deprecated_configs"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/discovery/versions/migrate-all"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "provider_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/migrate"

							if l := len("/migrate"); len(elem) >= l && elem[0:l] == "/migrate" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = MigrateProviderConfigOperation
									r.summary = "Migrate Provider Config"
									r.operationID = "migrate_provider_config"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/discovery/versions/{provider_id}/migrate"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'e': // Prefix: "en"

				if l := len("en"); len(elem) >= l && elem[0:l] == "en" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 't': // Prefix: "tit"

					if l := len("tit"); len(elem) >= l && elem[0:l] == "tit" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'i': // Prefix: "ies/"

						if l := len("ies/"); len(elem) >= l && elem[0:l] == "ies/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetEntitiesOperation
								r.summary = "Query entities with optional field selectors"
								r.operationID = "get_entities"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/entities/"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case 'b': // Prefix: "bulk"
							origElem := elem
							if l := len("bulk"); len(elem) >= l && elem[0:l] == "bulk" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "POST":
									r.name = CreateEntitiesBulkOperation
									r.summary = "Create multiple entities in bulk"
									r.operationID = "create_entities_bulk"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/bulk"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'd': // Prefix: "definitions"
							origElem := elem
							if l := len("definitions"); len(elem) >= l && elem[0:l] == "definitions" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetEntityDefinitionsOperation
									r.summary = "Retrieve all entity definitions with their versions"
									r.operationID = "get_entity_definitions"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/definitions"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateEntityDefinitionOperation
									r.summary = "Create Entity Definition"
									r.operationID = "create_entity_definition"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/definitions"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "definition_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteEntityDefinitionOperation
										r.summary = "Delete an entity definition"
										r.operationID = "delete_entity_definition"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/entities/definitions/{definition_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						case 'o': // Prefix: "orphans"
							origElem := elem
							if l := len("orphans"); len(elem) >= l && elem[0:l] == "orphans" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = CleanupOrphanedEntitiesOperation
									r.summary = "Clean up orphaned entities"
									r.operationID = "cleanup_orphaned_entities"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/orphans"
									r.args = args
									r.count = 0
									return r, true
								case "GET":
									r.name = ListOrphanedEntitiesOperation
									r.summary = "List orphaned entities"
									r.operationID = "list_orphaned_entities"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/orphans"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

							elem = origElem
						case 'r': // Prefix: "relations"
							origElem := elem
							if l := len("relations"); len(elem) >= l && elem[0:l] == "relations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = DeleteEntityRelationOperation
									r.summary = "Delete a relation between entities"
									r.operationID = "delete_entity_relation"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/relations"
									r.args = args
									r.count = 0
									return r, true
								case "GET":
									r.name = ListEntityRelationsOperation
									r.summary = "List relations with optional filtering"
									r.operationID = "list_entity_relations"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/relations"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateEntityRelationOperation
									r.summary = "Create Entity Relation"
									r.operationID = "create_entity_relation"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/relations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/bulk"

								if l := len("/bulk"); len(elem) >= l && elem[0:l] == "/bulk" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = CreateEntityRelationsBulkOperation
										r.summary = "Create multiple entity relations in bulk"
										r.operationID = "create_entity_relations_bulk"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/entities/relations/bulk"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						case 'u': // Prefix: "uid/"
							origElem := elem
							if l := len("uid/"); len(elem) >= l && elem[0:l] == "uid/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'b': // Prefix: "batch"
								origElem := elem
								if l := len("batch"); len(elem) >= l && elem[0:l] == "batch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "POST":
										r.name = GetEntitiesByUIDBatchOperation
										r.summary = "Retrieve multiple entities by UIDs in a single request"
										r.operationID = "get_entities_by_uid_batch"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/entities/uid/batch"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}

								elem = origElem
							}
							// Param: "uid"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = GetEntityByUIDOperation
									r.summary = "Retrieve a specific entity by UID with its relations"
									r.operationID = "get_entity_by_uid"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entities/uid/{uid}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

							elem = origElem
						}
						// Param: "group"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "version"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'n': // Prefix: "namespace/"
									origElem := elem
									if l := len("namespace/"); len(elem) >= l && elem[0:l] == "namespace/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "namespace"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[2] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "plural"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[3] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = CreateEntityOperation
												r.summary = "Create a resource based on an entity definition"
												r.operationID = "create_entity"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}"
												r.args = args
												r.count = 4
												return r, true
											default:
												return
											}
										}

									}

									elem = origElem
								}
								// Param: "kind"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[2] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "namespace"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[3] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"

										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "name"
										// Leaf parameter, slashes are prohibited
										idx := strings.IndexByte(elem, '/')
										if idx >= 0 {
											break
										}
										args[4] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "DELETE":
												r.name = DeleteEntityOperation
												r.summary = "Delete a specific entity"
												r.operationID = "delete_entity"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}"
												r.args = args
												r.count = 5
												return r, true
											case "GET":
												r.name = GetEntityOperation
												r.summary = "Retrieve a specific entity by name with its relations"
												r.operationID = "get_entity"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}"
												r.args = args
												r.count = 5
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						}

					case 'l': // Prefix: "lements"

						if l := len("lements"); len(elem) >= l && elem[0:l] == "lements" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = GetEntitlementsOperation
								r.summary = "Get Entitlements"
								r.operationID = "get_entitlements"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/entitlements"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/check/"

							if l := len("/check/"); len(elem) >= l && elem[0:l] == "/check/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "entitlement_type"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = CheckEntitlementOperation
									r.summary = "Check Entitlement"
									r.operationID = "check_entitlement"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/entitlements/check/{entitlement_type}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'v': // Prefix: "vironments"

					if l := len("vironments"); len(elem) >= l && elem[0:l] == "vironments" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GetEnvironmentsOperation
							r.summary = "Get Environments"
							r.operationID = "get_environments"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/environments"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateEnvironmentOperation
							r.summary = "Create Environment"
							r.operationID = "create_environment"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/environments"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "environment_id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = DeleteEnvironmentOperation
								r.summary = "Delete Environment"
								r.operationID = "delete_environment"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/environments/{env_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'd': // Prefix: "discovery-settings"

								if l := len("discovery-settings"); len(elem) >= l && elem[0:l] == "discovery-settings" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetEnvironmentDiscoverySettingsOperation
										r.summary = "Get Environment Discovery Settings"
										r.operationID = "get_environment_discovery_settings"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/environments/{env_id}/discovery-settings"
										r.args = args
										r.count = 1
										return r, true
									case "PATCH":
										r.name = UpdateEnvironmentDiscoverySettingsOperation
										r.summary = "Update Environment Discovery Settings"
										r.operationID = "update_environment_discovery_settings"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/environments/{env_id}/discovery-settings"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 's': // Prefix: "status"

								if l := len("status"); len(elem) >= l && elem[0:l] == "status" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetEnvironmentStatusOperation
										r.summary = "Get Environment Status"
										r.operationID = "get_environment_status"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/environments/{env_id}/status"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							case 'u': // Prefix: "users"

								if l := len("users"); len(elem) >= l && elem[0:l] == "users" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = ListEnvironmentUsersOperation
										r.summary = "List Environment Users"
										r.operationID = "list_environment_users"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/environments/{environment_id}/users"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = CreateEnvironmentUserOperation
										r.summary = "Create Environment User"
										r.operationID = "create_environment_user"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/environments/{environment_id}/users"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'b': // Prefix: "bulk-invite"
										origElem := elem
										if l := len("bulk-invite"); len(elem) >= l && elem[0:l] == "bulk-invite" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "POST":
												r.name = BulkInviteEnvironmentUsersOperation
												r.summary = "Bulk Invite Environment Users"
												r.operationID = "bulk_invite_environment_users"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/environments/{environment_id}/users/bulk-invite"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									case 'i': // Prefix: "invit"
										origElem := elem
										if l := len("invit"); len(elem) >= l && elem[0:l] == "invit" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "ations/"

											if l := len("ations/"); len(elem) >= l && elem[0:l] == "ations/" {
												elem = elem[l:]
											} else {
												break
											}

											// Param: "invitation_id"
											// Leaf parameter, slashes are prohibited
											idx := strings.IndexByte(elem, '/')
											if idx >= 0 {
												break
											}
											args[1] = elem
											elem = ""

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "DELETE":
													r.name = DeleteEnvironmentInvitationOperation
													r.summary = "Delete Environment Invitation"
													r.operationID = "delete_environment_invitation"
													r.operationGroup = ""
													r.pathPattern = "/api/v1/environments/{environment_id}/users/invitations/{invitation_id}"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}

										case 'e': // Prefix: "e"

											if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch method {
												case "POST":
													r.name = InviteEnvironmentUserOperation
													r.summary = "Invite Environment User"
													r.operationID = "invite_environment_user"
													r.operationGroup = ""
													r.pathPattern = "/api/v1/environments/{environment_id}/users/invite"
													r.args = args
													r.count = 1
													return r, true
												default:
													return
												}
											}

										}

										elem = origElem
									case 'p': // Prefix: "pending"
										origElem := elem
										if l := len("pending"); len(elem) >= l && elem[0:l] == "pending" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetPendingInvitationsOperation
												r.summary = "Get Pending Invitations"
												r.operationID = "get_pending_invitations"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/environments/{environment_id}/users/pending"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

										elem = origElem
									}
									// Param: "user_id"
									// Leaf parameter, slashes are prohibited
									idx := strings.IndexByte(elem, '/')
									if idx >= 0 {
										break
									}
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch method {
										case "DELETE":
											r.name = DeleteEnvironmentUserOperation
											r.summary = "Delete Environment User"
											r.operationID = "delete_environment_user"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/environments/{environment_id}/users/{user_id}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											r.name = GetEnvironmentUserOperation
											r.summary = "Get Environment User"
											r.operationID = "get_environment_user"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/environments/{environment_id}/users/{user_id}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											r.name = UpdateEnvironmentUserOperation
											r.summary = "Update Environment User"
											r.operationID = "update_environment_user"
											r.operationGroup = ""
											r.pathPattern = "/api/v1/environments/{environment_id}/users/{user_id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}

								}

							}

						}

					}

				}

			case 'm': // Prefix: "m"

				if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "cp/"

					if l := len("cp/"); len(elem) >= l && elem[0:l] == "cp/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'e': // Prefix: "en"

						if l := len("en"); len(elem) >= l && elem[0:l] == "en" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "dpoints"

							if l := len("dpoints"); len(elem) >= l && elem[0:l] == "dpoints" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetMcpendpointsOperation
									r.summary = "Get Mcpendpoints"
									r.operationID = "get_mcpendpoints"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mcp/endpoints"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateMcpendpointOperation
									r.summary = "Create Mcpendpoint"
									r.operationID = "create_mcpendpoint"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mcp/endpoints"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "mcpendpoint_id"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = DeleteMcpendpointOperation
										r.summary = "Delete Mcpendpoint"
										r.operationID = "delete_mcpendpoint"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mcp/endpoints/{mcpendpoint_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetMcpendpointOperation
										r.summary = "Get Mcpendpoint"
										r.operationID = "get_mcpendpoint"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mcp/endpoints/{mcpendpoint_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateMcpendpointOperation
										r.summary = "Update Mcpendpoint"
										r.operationID = "update_mcpendpoint"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mcp/endpoints/{mcpendpoint_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"

									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "entity-types"

										if l := len("entity-types"); len(elem) >= l && elem[0:l] == "entity-types" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = GetMcpEndpointEntityTypesOperation
												r.summary = "Get Mcp Endpoint Entity Types"
												r.operationID = "get_mcp_endpoint_entity_types"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/mcp/endpoints/{mcpendpoint_name}/entity-types"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									case 't': // Prefix: "tools"

										if l := len("tools"); len(elem) >= l && elem[0:l] == "tools" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch method {
											case "GET":
												r.name = ListMcpendpointToolsOperation
												r.summary = "List Mcpendpoint Tools"
												r.operationID = "list_mcpendpoint_tools"
												r.operationGroup = ""
												r.pathPattern = "/api/v1/mcp/endpoints/{mcpendpoint_id}/tools"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}

									}

								}

							}

						case 't': // Prefix: "tity-definitions/"

							if l := len("tity-definitions/"); len(elem) >= l && elem[0:l] == "tity-definitions/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "entity_definition_id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/tools"

								if l := len("/tools"); len(elem) >= l && elem[0:l] == "/tools" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "GET":
										r.name = GetEntityToolsOperation
										r.summary = "Get Entity Tools"
										r.operationID = "get_entity_tools"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mcp/entity-definitions/{entity_definition_id}/tools"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						}

					case 't': // Prefix: "tool"

						if l := len("tool"); len(elem) >= l && elem[0:l] == "tool" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-associations"

							if l := len("-associations"); len(elem) >= l && elem[0:l] == "-associations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = CreateMcpToolAssociationOperation
									r.summary = "Create Mcp Tool Association"
									r.operationID = "create_mcp_tool_association"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mcp/tool-associations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "association_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteMcpToolAssociationOperation
										r.summary = "Delete Mcp Tool Association"
										r.operationID = "delete_mcp_tool_association"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/mcp/tool-associations/{association_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

						case 's': // Prefix: "s"

							if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "GET":
									r.name = ListAllMcpToolsOperation
									r.summary = "List All Mcp Tools"
									r.operationID = "list_all_mcp_tools"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/mcp/tools"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}

						}

					}

				case 'o': // Prefix: "odels"

					if l := len("odels"); len(elem) >= l && elem[0:l] == "odels" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = GetModelsOperation
							r.summary = "Get Models"
							r.operationID = "get_models"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/models"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateModelOperation
							r.summary = "Create Model"
							r.operationID = "create_model"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/models"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "providers"
							origElem := elem
							if l := len("providers"); len(elem) >= l && elem[0:l] == "providers" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = GetModelprovidersOperation
									r.summary = "Get Modelproviders"
									r.operationID = "get_modelproviders"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/models/providers"
									r.args = args
									r.count = 0
									return r, true
								case "POST":
									r.name = CreateModelproviderOperation
									r.summary = "Create Modelprovider"
									r.operationID = "create_modelprovider"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/models/providers"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"

								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "provider_id"
								// Leaf parameter, slashes are prohibited
								idx := strings.IndexByte(elem, '/')
								if idx >= 0 {
									break
								}
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch method {
									case "DELETE":
										r.name = DeleteModelproviderOperation
										r.summary = "Delete Modelprovider"
										r.operationID = "delete_modelprovider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/models/providers/{provider_id}"
										r.args = args
										r.count = 1
										return r, true
									case "GET":
										r.name = GetModelproviderOperation
										r.summary = "Get Modelprovider"
										r.operationID = "get_modelprovider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/models/providers/{provider_id}"
										r.args = args
										r.count = 1
										return r, true
									case "PUT":
										r.name = UpdateModelproviderOperation
										r.summary = "Update Modelprovider"
										r.operationID = "update_modelprovider"
										r.operationGroup = ""
										r.pathPattern = "/api/v1/models/providers/{provider_id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}

							}

							elem = origElem
						}
						// Param: "model_name"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = DeleteModelOperation
								r.summary = "Delete Model"
								r.operationID = "delete_model"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/models/{model_name}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetModelOperation
								r.summary = "Get Model"
								r.operationID = "get_model"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/models/{model_name}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = UpdateModelOperation
								r.summary = "Update Model"
								r.operationID = "update_model"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/models/{model_name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				}

			case 'o': // Prefix: "oauth/"

				if l := len("oauth/"); len(elem) >= l && elem[0:l] == "oauth/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "authorize"

					if l := len("authorize"); len(elem) >= l && elem[0:l] == "authorize" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "POST":
							r.name = GetOAuthAuthorizationURLOperation
							r.summary = "Get Authorization Url"
							r.operationID = "get_oauth_authorization_url"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/oauth/authorize"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 'o': // Prefix: "oidc-config"

					if l := len("oidc-config"); len(elem) >= l && elem[0:l] == "oidc-config" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "GET":
							r.name = GetOidcConfigurationOperation
							r.summary = "Get OIDC Configuration"
							r.operationID = "get_oidc_configuration"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/oauth/oidc-config"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}

				case 's': // Prefix: "services"

					if l := len("services"); len(elem) >= l && elem[0:l] == "services" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = ListOAuthServicesOperation
							r.summary = "List Oauth Services"
							r.operationID = "list_oauth_services"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/oauth/services"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = CreateOAuthServiceOperation
							r.summary = "Create Oauth Service"
							r.operationID = "create_oauth_service"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/oauth/services"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"

						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "service_id"
						// Leaf parameter, slashes are prohibited
						idx := strings.IndexByte(elem, '/')
						if idx >= 0 {
							break
						}
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "DELETE":
								r.name = DeleteOAuthServiceOperation
								r.summary = "Delete Oauth Service"
								r.operationID = "delete_oauth_service"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oauth/services/{service_id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = GetOAuthServiceOperation
								r.summary = "Get Oauth Service"
								r.operationID = "get_oauth_service"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oauth/services/{service_id}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = UpdateOAuthServiceOperation
								r.summary = "Update Oauth Service"
								r.operationID = "update_oauth_service"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oauth/services/{service_id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}

					}

				case 't': // Prefix: "token"

					if l := len("token"); len(elem) >= l && elem[0:l] == "token" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							r.name = ExchangeOAuthTokenOperation
							r.summary = "Exchange Code For Token"
							r.operationID = "exchange_oauth_token"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/oauth/token"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case 's': // Prefix: "s"

						if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = ListOAuthTokensOperation
								r.summary = "List User Tokens"
								r.operationID = "list_oauth_tokens"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/oauth/tokens"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"

							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service_name"
							// Leaf parameter, slashes are prohibited
							idx := strings.IndexByte(elem, '/')
							if idx >= 0 {
								break
							}
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch method {
								case "DELETE":
									r.name = RevokeOAuthTokenOperation
									r.summary = "Revoke Token"
									r.operationID = "revoke_oauth_token"
									r.operationGroup = ""
									r.pathPattern = "/api/v1/oauth/tokens/{service_name}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}

						}

					}

				}

			case 'p': // Prefix: "prompts"

				if l := len("prompts"); len(elem) >= l && elem[0:l] == "prompts" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = ListPromptsOperation
						r.summary = "List Prompts"
						r.operationID = "list_prompts"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/prompts"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = CreatePromptOperation
						r.summary = "Create Prompt"
						r.operationID = "create_prompt"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/prompts"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 's': // Prefix: "system-default"
						origElem := elem
						if l := len("system-default"); len(elem) >= l && elem[0:l] == "system-default" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch method {
							case "GET":
								r.name = GetSystemDefaultPromptOperation
								r.summary = "Get System Default Prompt"
								r.operationID = "get_system_default_prompt"
								r.operationGroup = ""
								r.pathPattern = "/api/v1/prompts/system-default"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}

						elem = origElem
					}
					// Param: "prompt_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "DELETE":
							r.name = DeletePromptOperation
							r.summary = "Delete Prompt"
							r.operationID = "delete_prompt"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/prompts/{prompt_id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = GetPromptOperation
							r.summary = "Get Prompt"
							r.operationID = "get_prompt"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/prompts/{prompt_id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = UpdatePromptOperation
							r.summary = "Update Prompt"
							r.operationID = "update_prompt"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/prompts/{prompt_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			case 'r': // Prefix: "renderers/allowlist"

				if l := len("renderers/allowlist"); len(elem) >= l && elem[0:l] == "renderers/allowlist" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = GetRendererAllowlistAPIV1RenderersAllowlistGetOperation
						r.summary = "Get Renderer Allowlist"
						r.operationID = "get_renderer_allowlist_api_v1_renderers_allowlist_get"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/renderers/allowlist"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 's': // Prefix: "subscriptions"

				if l := len("subscriptions"); len(elem) >= l && elem[0:l] == "subscriptions" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch method {
					case "GET":
						r.name = GetSubscriptionsOperation
						r.summary = "Get Subscriptions"
						r.operationID = "get_subscriptions"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/subscriptions"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}

			case 't': // Prefix: "tokens"

				if l := len("tokens"); len(elem) >= l && elem[0:l] == "tokens" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = GetTokensOperation
						r.summary = "Get Tokens"
						r.operationID = "get_tokens"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/tokens"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = CreateTokenOperation
						r.summary = "Create Token"
						r.operationID = "create_token"
						r.operationGroup = ""
						r.pathPattern = "/api/v1/tokens"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"

					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "token_id"
					// Leaf parameter, slashes are prohibited
					idx := strings.IndexByte(elem, '/')
					if idx >= 0 {
						break
					}
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch method {
						case "DELETE":
							r.name = DeleteTokenOperation
							r.summary = "Delete Token"
							r.operationID = "delete_token"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/tokens/{token_id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = UpdateTokenOperation
							r.summary = "Update Token"
							r.operationID = "update_token"
							r.operationGroup = ""
							r.pathPattern = "/api/v1/tokens/{token_id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}

				}

			}

		}
	}
	return r, false
}
