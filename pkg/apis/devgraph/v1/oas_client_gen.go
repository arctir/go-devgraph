// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// BulkInviteEnvironmentUsers invokes bulk_invite_environment_users operation.
	//
	// Bulk invite multiple users to an environment (organization).
	//
	// POST /system/api/v1/environments/{environment_id}/users/bulk-invite
	BulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (BulkInviteEnvironmentUsersRes, error)
	// CreateChat invokes create_chat operation.
	//
	// Create Chat.
	//
	// POST /api/v1/chat/
	CreateChat(ctx context.Context, request *ChatSessionCreate) (CreateChatRes, error)
	// CreateChatTitle invokes create_chat_title operation.
	//
	// Generate a title for a chat based on the first message.
	//
	// POST /api/v1/chat/title
	CreateChatTitle(ctx context.Context, request *ChatTitleRequest) (CreateChatTitleRes, error)
	// CreateEntity invokes create_entity operation.
	//
	// Creates a new entity based on the specified group, version, namespace, and kind. Requires
	// 'create:entities' permission.
	//
	// POST /api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}
	CreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (CreateEntityRes, error)
	// CreateEntityDefinition invokes create_entity_definition operation.
	//
	// Create Entity Definition.
	//
	// POST /api/v1/entities/definitions
	CreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (CreateEntityDefinitionRes, error)
	// CreateEntityRelation invokes create_entity_relation operation.
	//
	// Create Entity Relation.
	//
	// POST /api/v1/entities/relations
	CreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (CreateEntityRelationRes, error)
	// CreateEnvironment invokes create_environment operation.
	//
	// Create Environment.
	//
	// POST /system/api/v1/environments
	CreateEnvironment(ctx context.Context, request *EnvironmentCreate) (CreateEnvironmentRes, error)
	// CreateEnvironmentUser invokes create_environment_user operation.
	//
	// Create a new environment user by adding them to the Clerk organization.
	//
	// POST /system/api/v1/environments/{environment_id}/users
	CreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (CreateEnvironmentUserRes, error)
	// CreateMcpendpoint invokes create_mcpendpoint operation.
	//
	// Create a new MCP Endpoint configuration.
	//
	// POST /system/api/v1/mcpendpoints
	CreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (CreateMcpendpointRes, error)
	// CreateModel invokes create_model operation.
	//
	// Create a new model configuration.
	//
	// POST /system/api/v1/models
	CreateModel(ctx context.Context, request *ModelCreate) (CreateModelRes, error)
	// CreateModelprovider invokes create_modelprovider operation.
	//
	// Create a new Model Provider configuration.
	//
	// POST /system/api/v1/modelproviders
	CreateModelprovider(ctx context.Context, request *ModelProviderCreate) (CreateModelproviderRes, error)
	// CreateOAuthService invokes create_oauth_service operation.
	//
	// Create Oauth Service.
	//
	// POST /api/v1/oauth/services
	CreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (CreateOAuthServiceRes, error)
	// CreateToken invokes create_token operation.
	//
	// Create Token.
	//
	// POST /system/api/v1/tokens
	CreateToken(ctx context.Context, request *ApiTokenCreate) (CreateTokenRes, error)
	// DeleteChat invokes delete_chat operation.
	//
	// Delete Chat.
	//
	// DELETE /api/v1/chat/{chat_id}
	DeleteChat(ctx context.Context, params DeleteChatParams) (DeleteChatRes, error)
	// DeleteEntity invokes delete_entity operation.
	//
	// Deletes a specific entity from the knowledge graph. Requires 'delete:entities' permission.
	//
	// DELETE /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
	DeleteEntity(ctx context.Context, params DeleteEntityParams) (DeleteEntityRes, error)
	// DeleteEntityDefinition invokes delete_entity_definition operation.
	//
	// Deletes an entity definition and all its versions. Requires 'delete:entitydefinitions' permission.
	//
	// DELETE /api/v1/entities/definitions/{definition_id}
	DeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (DeleteEntityDefinitionRes, error)
	// DeleteEntityRelation invokes delete_entity_relation operation.
	//
	// Deletes a specific relation between two entities. Requires 'delete:entityrelations' permission.
	//
	// DELETE /api/v1/entities/relations
	DeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (DeleteEntityRelationRes, error)
	// DeleteEnvironmentUser invokes delete_environment_user operation.
	//
	// Remove a user from an environment (organization).
	//
	// DELETE /system/api/v1/environments/{environment_id}/users/{user_id}
	DeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (DeleteEnvironmentUserRes, error)
	// DeleteMcpendpoint invokes delete_mcpendpoint operation.
	//
	// Delete a specific MCP Endpoint configuration by ID.
	//
	// DELETE /system/api/v1/mcpendpoints/{mcpendpoint_id}
	DeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (DeleteMcpendpointRes, error)
	// DeleteModel invokes delete_model operation.
	//
	// Delete a specific model configuration by name.
	//
	// DELETE /system/api/v1/models/{model_name}
	DeleteModel(ctx context.Context, params DeleteModelParams) (DeleteModelRes, error)
	// DeleteModelprovider invokes delete_modelprovider operation.
	//
	// Delete a specific Model Provider configuration by ID.
	//
	// DELETE /system/api/v1/modelproviders/{provider_id}
	DeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (DeleteModelproviderRes, error)
	// DeleteOAuthService invokes delete_oauth_service operation.
	//
	// Delete Oauth Service.
	//
	// DELETE /api/v1/oauth/services/{service_id}
	DeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (DeleteOAuthServiceRes, error)
	// ExchangeOAuthToken invokes exchange_oauth_token operation.
	//
	// Exchange Code For Token.
	//
	// POST /api/v1/oauth/token
	ExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (ExchangeOAuthTokenRes, error)
	// GetChat invokes get_chat operation.
	//
	// Get Chat.
	//
	// GET /api/v1/chat/{chat_id}
	GetChat(ctx context.Context, params GetChatParams) (GetChatRes, error)
	// GetChatMessages invokes get_chat_messages operation.
	//
	// Get Chat Messages.
	//
	// GET /api/v1/chat/{chat_id}/messages
	GetChatMessages(ctx context.Context, params GetChatMessagesParams) (GetChatMessagesRes, error)
	// GetChats invokes get_chats operation.
	//
	// Get Chats.
	//
	// GET /api/v1/chat/
	GetChats(ctx context.Context, params GetChatsParams) (GetChatsRes, error)
	// GetEntities invokes get_entities operation.
	//
	// Retrieves entities from the knowledge graph, optionally filtered by field selectors. Field
	// selectors use dot notation for nested properties (e.g., 'spec.metadata.owner=team-a'). Requires
	// 'read:entities' permission.
	//
	// GET /api/v1/entities/
	GetEntities(ctx context.Context, params GetEntitiesParams) (GetEntitiesRes, error)
	// GetEntity invokes get_entity operation.
	//
	// Fetches a specific entity based on group, version, namespace, plural, and name. Requires
	// 'read:entities' permission.
	//
	// GET /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
	GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error)
	// GetEntityDefinitions invokes get_entity_definitions operation.
	//
	// Fetches a list of all entity definitions and their associated versions from the database. Requires
	// 'list:entitydefinitions' permission.
	//
	// GET /api/v1/entities/definitions
	GetEntityDefinitions(ctx context.Context) (GetEntityDefinitionsRes, error)
	// GetEnvironmentStatus invokes get_environment_status operation.
	//
	// Get Environment Status.
	//
	// GET /system/api/v1/environments/{env_id}/status
	GetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (GetEnvironmentStatusRes, error)
	// GetEnvironmentUser invokes get_environment_user operation.
	//
	// Get a specific environment user.
	//
	// GET /system/api/v1/environments/{environment_id}/users/{user_id}
	GetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (GetEnvironmentUserRes, error)
	// GetEnvironments invokes get_environments operation.
	//
	// Get Environments.
	//
	// GET /system/api/v1/environments
	GetEnvironments(ctx context.Context) (GetEnvironmentsRes, error)
	// GetMcpendpoint invokes get_mcpendpoint operation.
	//
	// Get a specific MCP Endpoint configuration by ID.
	//
	// GET /system/api/v1/mcpendpoints/{mcpendpoint_id}
	GetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (GetMcpendpointRes, error)
	// GetMcpendpoints invokes get_mcpendpoints operation.
	//
	// List all MCP Endpoint configurations for the authenticated user and environment.
	//
	// GET /system/api/v1/mcpendpoints
	GetMcpendpoints(ctx context.Context) (GetMcpendpointsRes, error)
	// GetModel invokes get_model operation.
	//
	// Get a specific model configuration by name.
	//
	// GET /system/api/v1/models/{model_name}
	GetModel(ctx context.Context, params GetModelParams) (GetModelRes, error)
	// GetModelprovider invokes get_modelprovider operation.
	//
	// Get a specific Model Provider configuration by ID.
	//
	// GET /system/api/v1/modelproviders/{provider_id}
	GetModelprovider(ctx context.Context, params GetModelproviderParams) (GetModelproviderRes, error)
	// GetModelproviders invokes get_modelproviders operation.
	//
	// List all Model Provider configurations for the authenticated user and environment.
	//
	// GET /system/api/v1/modelproviders
	GetModelproviders(ctx context.Context) (GetModelprovidersRes, error)
	// GetModels invokes get_models operation.
	//
	// List all model configurations for the authenticated user and environment.
	//
	// GET /system/api/v1/models
	GetModels(ctx context.Context) (GetModelsRes, error)
	// GetOAuthAuthorizationURL invokes get_oauth_authorization_url operation.
	//
	// Get Authorization Url.
	//
	// POST /api/v1/oauth/authorize
	GetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (GetOAuthAuthorizationURLRes, error)
	// GetOAuthService invokes get_oauth_service operation.
	//
	// Get Oauth Service.
	//
	// GET /api/v1/oauth/services/{service_id}
	GetOAuthService(ctx context.Context, params GetOAuthServiceParams) (GetOAuthServiceRes, error)
	// GetSubscriptions invokes get_subscriptions operation.
	//
	// Get Subscriptions.
	//
	// GET /system/api/v1/subscriptions
	GetSubscriptions(ctx context.Context) (GetSubscriptionsRes, error)
	// GetTokens invokes get_tokens operation.
	//
	// Get all API tokens for the authenticated user.
	//
	// GET /system/api/v1/tokens
	GetTokens(ctx context.Context) (GetTokensRes, error)
	// InviteEnvironmentUser invokes invite_environment_user operation.
	//
	// Invite a user to an environment (organization).
	//
	// POST /system/api/v1/environments/{environment_id}/users/invite
	InviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (InviteEnvironmentUserRes, error)
	// ListEnvironmentUsers invokes list_environment_users operation.
	//
	// List all users in an environment (organization members).
	//
	// GET /system/api/v1/environments/{environment_id}/users
	ListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (ListEnvironmentUsersRes, error)
	// ListOAuthServices invokes list_oauth_services operation.
	//
	// List Oauth Services.
	//
	// GET /api/v1/oauth/services
	ListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (ListOAuthServicesRes, error)
	// ListOAuthTokens invokes list_oauth_tokens operation.
	//
	// List User Tokens.
	//
	// GET /api/v1/oauth/tokens
	ListOAuthTokens(ctx context.Context) (ListOAuthTokensRes, error)
	// PostChatMessages invokes post_chat_messages operation.
	//
	// Post Chat Messages.
	//
	// POST /api/v1/chat/{chat_id}/messages
	PostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (PostChatMessagesRes, error)
	// PostClerkWebhook invokes post_clerk_webhook operation.
	//
	// Post Clerk Webhook.
	//
	// POST /system/api/v1/webhooks/clerk
	PostClerkWebhook(ctx context.Context, params PostClerkWebhookParams) (PostClerkWebhookRes, error)
	// PostStripeWebhook invokes post_stripe_webhook operation.
	//
	// Post Stripe Webhook.
	//
	// POST /system/api/v1/webhooks/stripe
	PostStripeWebhook(ctx context.Context, params PostStripeWebhookParams) (PostStripeWebhookRes, error)
	// RevokeOAuthToken invokes revoke_oauth_token operation.
	//
	// Revoke Token.
	//
	// DELETE /api/v1/oauth/tokens/{service_name}
	RevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (RevokeOAuthTokenRes, error)
	// UpdateChat invokes update_chat operation.
	//
	// Update Chat.
	//
	// PUT /api/v1/chat/{chat_id}
	UpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (UpdateChatRes, error)
	// UpdateEnvironmentUser invokes update_environment_user operation.
	//
	// Update an environment user's role.
	//
	// PUT /system/api/v1/environments/{environment_id}/users/{user_id}
	UpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (UpdateEnvironmentUserRes, error)
	// UpdateOAuthService invokes update_oauth_service operation.
	//
	// Update Oauth Service.
	//
	// PUT /api/v1/oauth/services/{service_id}
	UpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (UpdateOAuthServiceRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// BulkInviteEnvironmentUsers invokes bulk_invite_environment_users operation.
//
// Bulk invite multiple users to an environment (organization).
//
// POST /system/api/v1/environments/{environment_id}/users/bulk-invite
func (c *Client) BulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (BulkInviteEnvironmentUsersRes, error) {
	res, err := c.sendBulkInviteEnvironmentUsers(ctx, request, params)
	return res, err
}

func (c *Client) sendBulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (res BulkInviteEnvironmentUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/bulk-invite"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBulkInviteEnvironmentUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, BulkInviteEnvironmentUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeBulkInviteEnvironmentUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChat invokes create_chat operation.
//
// Create Chat.
//
// POST /api/v1/chat/
func (c *Client) CreateChat(ctx context.Context, request *ChatSessionCreate) (CreateChatRes, error) {
	res, err := c.sendCreateChat(ctx, request)
	return res, err
}

func (c *Client) sendCreateChat(ctx context.Context, request *ChatSessionCreate) (res CreateChatRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chat/"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatTitle invokes create_chat_title operation.
//
// Generate a title for a chat based on the first message.
//
// POST /api/v1/chat/title
func (c *Client) CreateChatTitle(ctx context.Context, request *ChatTitleRequest) (CreateChatTitleRes, error) {
	res, err := c.sendCreateChatTitle(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatTitle(ctx context.Context, request *ChatTitleRequest) (res CreateChatTitleRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chat/title"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateChatTitleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateChatTitleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntity invokes create_entity operation.
//
// Creates a new entity based on the specified group, version, namespace, and kind. Requires
// 'create:entities' permission.
//
// POST /api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}
func (c *Client) CreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (CreateEntityRes, error) {
	res, err := c.sendCreateEntity(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (res CreateEntityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/namespace/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "plural" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plural",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Plural))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntityDefinition invokes create_entity_definition operation.
//
// Create Entity Definition.
//
// POST /api/v1/entities/definitions
func (c *Client) CreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (CreateEntityDefinitionRes, error) {
	res, err := c.sendCreateEntityDefinition(ctx, request)
	return res, err
}

func (c *Client) sendCreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (res CreateEntityDefinitionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/definitions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityDefinitionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityDefinitionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEntityDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntityRelation invokes create_entity_relation operation.
//
// Create Entity Relation.
//
// POST /api/v1/entities/relations
func (c *Client) CreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (CreateEntityRelationRes, error) {
	res, err := c.sendCreateEntityRelation(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (res CreateEntityRelationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/relations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityRelationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityRelationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEntityRelationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironment invokes create_environment operation.
//
// Create Environment.
//
// POST /system/api/v1/environments
func (c *Client) CreateEnvironment(ctx context.Context, request *EnvironmentCreate) (CreateEnvironmentRes, error) {
	res, err := c.sendCreateEnvironment(ctx, request)
	return res, err
}

func (c *Client) sendCreateEnvironment(ctx context.Context, request *EnvironmentCreate) (res CreateEnvironmentRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEnvironmentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironmentUser invokes create_environment_user operation.
//
// Create a new environment user by adding them to the Clerk organization.
//
// POST /system/api/v1/environments/{environment_id}/users
func (c *Client) CreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (CreateEnvironmentUserRes, error) {
	res, err := c.sendCreateEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (res CreateEnvironmentUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMcpendpoint invokes create_mcpendpoint operation.
//
// Create a new MCP Endpoint configuration.
//
// POST /system/api/v1/mcpendpoints
func (c *Client) CreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (CreateMcpendpointRes, error) {
	res, err := c.sendCreateMcpendpoint(ctx, request)
	return res, err
}

func (c *Client) sendCreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (res CreateMcpendpointRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/mcpendpoints"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMcpendpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateModel invokes create_model operation.
//
// Create a new model configuration.
//
// POST /system/api/v1/models
func (c *Client) CreateModel(ctx context.Context, request *ModelCreate) (CreateModelRes, error) {
	res, err := c.sendCreateModel(ctx, request)
	return res, err
}

func (c *Client) sendCreateModel(ctx context.Context, request *ModelCreate) (res CreateModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateModelprovider invokes create_modelprovider operation.
//
// Create a new Model Provider configuration.
//
// POST /system/api/v1/modelproviders
func (c *Client) CreateModelprovider(ctx context.Context, request *ModelProviderCreate) (CreateModelproviderRes, error) {
	res, err := c.sendCreateModelprovider(ctx, request)
	return res, err
}

func (c *Client) sendCreateModelprovider(ctx context.Context, request *ModelProviderCreate) (res CreateModelproviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/modelproviders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateModelproviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOAuthService invokes create_oauth_service operation.
//
// Create Oauth Service.
//
// POST /api/v1/oauth/services
func (c *Client) CreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (CreateOAuthServiceRes, error) {
	res, err := c.sendCreateOAuthService(ctx, request)
	return res, err
}

func (c *Client) sendCreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (res CreateOAuthServiceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/services"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOAuthServiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateToken invokes create_token operation.
//
// Create Token.
//
// POST /system/api/v1/tokens
func (c *Client) CreateToken(ctx context.Context, request *ApiTokenCreate) (CreateTokenRes, error) {
	res, err := c.sendCreateToken(ctx, request)
	return res, err
}

func (c *Client) sendCreateToken(ctx context.Context, request *ApiTokenCreate) (res CreateTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, CreateTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChat invokes delete_chat operation.
//
// Delete Chat.
//
// DELETE /api/v1/chat/{chat_id}
func (c *Client) DeleteChat(ctx context.Context, params DeleteChatParams) (DeleteChatRes, error) {
	res, err := c.sendDeleteChat(ctx, params)
	return res, err
}

func (c *Client) sendDeleteChat(ctx context.Context, params DeleteChatParams) (res DeleteChatRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chat/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntity invokes delete_entity operation.
//
// Deletes a specific entity from the knowledge graph. Requires 'delete:entities' permission.
//
// DELETE /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
func (c *Client) DeleteEntity(ctx context.Context, params DeleteEntityParams) (DeleteEntityRes, error) {
	res, err := c.sendDeleteEntity(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEntity(ctx context.Context, params DeleteEntityParams) (res DeleteEntityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [10]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "kind" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kind",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Kind))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[9] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntityDefinition invokes delete_entity_definition operation.
//
// Deletes an entity definition and all its versions. Requires 'delete:entitydefinitions' permission.
//
// DELETE /api/v1/entities/definitions/{definition_id}
func (c *Client) DeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (DeleteEntityDefinitionRes, error) {
	res, err := c.sendDeleteEntityDefinition(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (res DeleteEntityDefinitionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/entities/definitions/"
	{
		// Encode "definition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "definition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DefinitionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityDefinitionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteEntityDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntityRelation invokes delete_entity_relation operation.
//
// Deletes a specific relation between two entities. Requires 'delete:entityrelations' permission.
//
// DELETE /api/v1/entities/relations
func (c *Client) DeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (DeleteEntityRelationRes, error) {
	res, err := c.sendDeleteEntityRelation(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (res DeleteEntityRelationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/relations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteEntityRelationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityRelationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteEntityRelationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEnvironmentUser invokes delete_environment_user operation.
//
// Remove a user from an environment (organization).
//
// DELETE /system/api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) DeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (DeleteEnvironmentUserRes, error) {
	res, err := c.sendDeleteEnvironmentUser(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (res DeleteEnvironmentUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMcpendpoint invokes delete_mcpendpoint operation.
//
// Delete a specific MCP Endpoint configuration by ID.
//
// DELETE /system/api/v1/mcpendpoints/{mcpendpoint_id}
func (c *Client) DeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (DeleteMcpendpointRes, error) {
	res, err := c.sendDeleteMcpendpoint(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (res DeleteMcpendpointRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/mcpendpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteModel invokes delete_model operation.
//
// Delete a specific model configuration by name.
//
// DELETE /system/api/v1/models/{model_name}
func (c *Client) DeleteModel(ctx context.Context, params DeleteModelParams) (DeleteModelRes, error) {
	res, err := c.sendDeleteModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteModel(ctx context.Context, params DeleteModelParams) (res DeleteModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/models/"
	{
		// Encode "model_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteModelprovider invokes delete_modelprovider operation.
//
// Delete a specific Model Provider configuration by ID.
//
// DELETE /system/api/v1/modelproviders/{provider_id}
func (c *Client) DeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (DeleteModelproviderRes, error) {
	res, err := c.sendDeleteModelprovider(ctx, params)
	return res, err
}

func (c *Client) sendDeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (res DeleteModelproviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/modelproviders/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOAuthService invokes delete_oauth_service operation.
//
// Delete Oauth Service.
//
// DELETE /api/v1/oauth/services/{service_id}
func (c *Client) DeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (DeleteOAuthServiceRes, error) {
	res, err := c.sendDeleteOAuthService(ctx, params)
	return res, err
}

func (c *Client) sendDeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (res DeleteOAuthServiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExchangeOAuthToken invokes exchange_oauth_token operation.
//
// Exchange Code For Token.
//
// POST /api/v1/oauth/token
func (c *Client) ExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (ExchangeOAuthTokenRes, error) {
	res, err := c.sendExchangeOAuthToken(ctx, request)
	return res, err
}

func (c *Client) sendExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (res ExchangeOAuthTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExchangeOAuthTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, ExchangeOAuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExchangeOAuthTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChat invokes get_chat operation.
//
// Get Chat.
//
// GET /api/v1/chat/{chat_id}
func (c *Client) GetChat(ctx context.Context, params GetChatParams) (GetChatRes, error) {
	res, err := c.sendGetChat(ctx, params)
	return res, err
}

func (c *Client) sendGetChat(ctx context.Context, params GetChatParams) (res GetChatRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chat/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMessages invokes get_chat_messages operation.
//
// Get Chat Messages.
//
// GET /api/v1/chat/{chat_id}/messages
func (c *Client) GetChatMessages(ctx context.Context, params GetChatMessagesParams) (GetChatMessagesRes, error) {
	res, err := c.sendGetChatMessages(ctx, params)
	return res, err
}

func (c *Client) sendGetChatMessages(ctx context.Context, params GetChatMessagesParams) (res GetChatMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/chat/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChats invokes get_chats operation.
//
// Get Chats.
//
// GET /api/v1/chat/
func (c *Client) GetChats(ctx context.Context, params GetChatsParams) (GetChatsRes, error) {
	res, err := c.sendGetChats(ctx, params)
	return res, err
}

func (c *Client) sendGetChats(ctx context.Context, params GetChatsParams) (res GetChatsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chat/"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntities invokes get_entities operation.
//
// Retrieves entities from the knowledge graph, optionally filtered by field selectors. Field
// selectors use dot notation for nested properties (e.g., 'spec.metadata.owner=team-a'). Requires
// 'read:entities' permission.
//
// GET /api/v1/entities/
func (c *Client) GetEntities(ctx context.Context, params GetEntitiesParams) (GetEntitiesRes, error) {
	res, err := c.sendGetEntities(ctx, params)
	return res, err
}

func (c *Client) sendGetEntities(ctx context.Context, params GetEntitiesParams) (res GetEntitiesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "label" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "label",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Label.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "fieldSelector" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FieldSelector.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntitiesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntity invokes get_entity operation.
//
// Fetches a specific entity based on group, version, namespace, plural, and name. Requires
// 'read:entities' permission.
//
// GET /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
func (c *Client) GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error) {
	res, err := c.sendGetEntity(ctx, params)
	return res, err
}

func (c *Client) sendGetEntity(ctx context.Context, params GetEntityParams) (res GetEntityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [10]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "kind" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kind",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Kind))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[9] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityDefinitions invokes get_entity_definitions operation.
//
// Fetches a list of all entity definitions and their associated versions from the database. Requires
// 'list:entitydefinitions' permission.
//
// GET /api/v1/entities/definitions
func (c *Client) GetEntityDefinitions(ctx context.Context) (GetEntityDefinitionsRes, error) {
	res, err := c.sendGetEntityDefinitions(ctx)
	return res, err
}

func (c *Client) sendGetEntityDefinitions(ctx context.Context) (res GetEntityDefinitionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/definitions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntityDefinitionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEntityDefinitionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentStatus invokes get_environment_status operation.
//
// Get Environment Status.
//
// GET /system/api/v1/environments/{env_id}/status
func (c *Client) GetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (GetEnvironmentStatusRes, error) {
	res, err := c.sendGetEnvironmentStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (res GetEnvironmentStatusRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "env_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "env_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentUser invokes get_environment_user operation.
//
// Get a specific environment user.
//
// GET /system/api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) GetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (GetEnvironmentUserRes, error) {
	res, err := c.sendGetEnvironmentUser(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (res GetEnvironmentUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironments invokes get_environments operation.
//
// Get Environments.
//
// GET /system/api/v1/environments
func (c *Client) GetEnvironments(ctx context.Context) (GetEnvironmentsRes, error) {
	res, err := c.sendGetEnvironments(ctx)
	return res, err
}

func (c *Client) sendGetEnvironments(ctx context.Context) (res GetEnvironmentsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpendpoint invokes get_mcpendpoint operation.
//
// Get a specific MCP Endpoint configuration by ID.
//
// GET /system/api/v1/mcpendpoints/{mcpendpoint_id}
func (c *Client) GetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (GetMcpendpointRes, error) {
	res, err := c.sendGetMcpendpoint(ctx, params)
	return res, err
}

func (c *Client) sendGetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (res GetMcpendpointRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/mcpendpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpendpoints invokes get_mcpendpoints operation.
//
// List all MCP Endpoint configurations for the authenticated user and environment.
//
// GET /system/api/v1/mcpendpoints
func (c *Client) GetMcpendpoints(ctx context.Context) (GetMcpendpointsRes, error) {
	res, err := c.sendGetMcpendpoints(ctx)
	return res, err
}

func (c *Client) sendGetMcpendpoints(ctx context.Context) (res GetMcpendpointsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/mcpendpoints"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetMcpendpointsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMcpendpointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModel invokes get_model operation.
//
// Get a specific model configuration by name.
//
// GET /system/api/v1/models/{model_name}
func (c *Client) GetModel(ctx context.Context, params GetModelParams) (GetModelRes, error) {
	res, err := c.sendGetModel(ctx, params)
	return res, err
}

func (c *Client) sendGetModel(ctx context.Context, params GetModelParams) (res GetModelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/models/"
	{
		// Encode "model_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModelprovider invokes get_modelprovider operation.
//
// Get a specific Model Provider configuration by ID.
//
// GET /system/api/v1/modelproviders/{provider_id}
func (c *Client) GetModelprovider(ctx context.Context, params GetModelproviderParams) (GetModelproviderRes, error) {
	res, err := c.sendGetModelprovider(ctx, params)
	return res, err
}

func (c *Client) sendGetModelprovider(ctx context.Context, params GetModelproviderParams) (res GetModelproviderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/system/api/v1/modelproviders/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModelproviders invokes get_modelproviders operation.
//
// List all Model Provider configurations for the authenticated user and environment.
//
// GET /system/api/v1/modelproviders
func (c *Client) GetModelproviders(ctx context.Context) (GetModelprovidersRes, error) {
	res, err := c.sendGetModelproviders(ctx)
	return res, err
}

func (c *Client) sendGetModelproviders(ctx context.Context) (res GetModelprovidersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/modelproviders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelprovidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetModelprovidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModels invokes get_models operation.
//
// List all model configurations for the authenticated user and environment.
//
// GET /system/api/v1/models
func (c *Client) GetModels(ctx context.Context) (GetModelsRes, error) {
	res, err := c.sendGetModels(ctx)
	return res, err
}

func (c *Client) sendGetModels(ctx context.Context) (res GetModelsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/models"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOAuthAuthorizationURL invokes get_oauth_authorization_url operation.
//
// Get Authorization Url.
//
// POST /api/v1/oauth/authorize
func (c *Client) GetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (GetOAuthAuthorizationURLRes, error) {
	res, err := c.sendGetOAuthAuthorizationURL(ctx, request)
	return res, err
}

func (c *Client) sendGetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (res GetOAuthAuthorizationURLRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetOAuthAuthorizationURLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetOAuthAuthorizationURLOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOAuthAuthorizationURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOAuthService invokes get_oauth_service operation.
//
// Get Oauth Service.
//
// GET /api/v1/oauth/services/{service_id}
func (c *Client) GetOAuthService(ctx context.Context, params GetOAuthServiceParams) (GetOAuthServiceRes, error) {
	res, err := c.sendGetOAuthService(ctx, params)
	return res, err
}

func (c *Client) sendGetOAuthService(ctx context.Context, params GetOAuthServiceParams) (res GetOAuthServiceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSubscriptions invokes get_subscriptions operation.
//
// Get Subscriptions.
//
// GET /system/api/v1/subscriptions
func (c *Client) GetSubscriptions(ctx context.Context) (GetSubscriptionsRes, error) {
	res, err := c.sendGetSubscriptions(ctx)
	return res, err
}

func (c *Client) sendGetSubscriptions(ctx context.Context) (res GetSubscriptionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTokens invokes get_tokens operation.
//
// Get all API tokens for the authenticated user.
//
// GET /system/api/v1/tokens
func (c *Client) GetTokens(ctx context.Context) (GetTokensRes, error) {
	res, err := c.sendGetTokens(ctx)
	return res, err
}

func (c *Client) sendGetTokens(ctx context.Context) (res GetTokensRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, GetTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InviteEnvironmentUser invokes invite_environment_user operation.
//
// Invite a user to an environment (organization).
//
// POST /system/api/v1/environments/{environment_id}/users/invite
func (c *Client) InviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (InviteEnvironmentUserRes, error) {
	res, err := c.sendInviteEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendInviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (res InviteEnvironmentUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/invite"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInviteEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, InviteEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInviteEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListEnvironmentUsers invokes list_environment_users operation.
//
// List all users in an environment (organization members).
//
// GET /system/api/v1/environments/{environment_id}/users
func (c *Client) ListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (ListEnvironmentUsersRes, error) {
	res, err := c.sendListEnvironmentUsers(ctx, params)
	return res, err
}

func (c *Client) sendListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (res ListEnvironmentUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, ListEnvironmentUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListEnvironmentUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOAuthServices invokes list_oauth_services operation.
//
// List Oauth Services.
//
// GET /api/v1/oauth/services
func (c *Client) ListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (ListOAuthServicesRes, error) {
	res, err := c.sendListOAuthServices(ctx, params)
	return res, err
}

func (c *Client) sendListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (res ListOAuthServicesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/services"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "active_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "active_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ActiveOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, ListOAuthServicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListOAuthServicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOAuthTokens invokes list_oauth_tokens operation.
//
// List User Tokens.
//
// GET /api/v1/oauth/tokens
func (c *Client) ListOAuthTokens(ctx context.Context) (ListOAuthTokensRes, error) {
	res, err := c.sendListOAuthTokens(ctx)
	return res, err
}

func (c *Client) sendListOAuthTokens(ctx context.Context) (res ListOAuthTokensRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, ListOAuthTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeListOAuthTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostChatMessages invokes post_chat_messages operation.
//
// Post Chat Messages.
//
// POST /api/v1/chat/{chat_id}/messages
func (c *Client) PostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (PostChatMessagesRes, error) {
	res, err := c.sendPostChatMessages(ctx, request, params)
	return res, err
}

func (c *Client) sendPostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (res PostChatMessagesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if request == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/chat/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostChatMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, PostChatMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostChatMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostClerkWebhook invokes post_clerk_webhook operation.
//
// Post Clerk Webhook.
//
// POST /system/api/v1/webhooks/clerk
func (c *Client) PostClerkWebhook(ctx context.Context, params PostClerkWebhookParams) (PostClerkWebhookRes, error) {
	res, err := c.sendPostClerkWebhook(ctx, params)
	return res, err
}

func (c *Client) sendPostClerkWebhook(ctx context.Context, params PostClerkWebhookParams) (res PostClerkWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/webhooks/clerk"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Svix-Id",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SvixID))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Svix-Timestamp",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SvixTimestamp))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Svix-Signature",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.SvixSignature))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostClerkWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostStripeWebhook invokes post_stripe_webhook operation.
//
// Post Stripe Webhook.
//
// POST /system/api/v1/webhooks/stripe
func (c *Client) PostStripeWebhook(ctx context.Context, params PostStripeWebhookParams) (PostStripeWebhookRes, error) {
	res, err := c.sendPostStripeWebhook(ctx, params)
	return res, err
}

func (c *Client) sendPostStripeWebhook(ctx context.Context, params PostStripeWebhookParams) (res PostStripeWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/system/api/v1/webhooks/stripe"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Stripe-Signature",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.StripeSignature))
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostStripeWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeOAuthToken invokes revoke_oauth_token operation.
//
// Revoke Token.
//
// DELETE /api/v1/oauth/tokens/{service_name}
func (c *Client) RevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (RevokeOAuthTokenRes, error) {
	res, err := c.sendRevokeOAuthToken(ctx, params)
	return res, err
}

func (c *Client) sendRevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (res RevokeOAuthTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/tokens/"
	{
		// Encode "service_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, RevokeOAuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeOAuthTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateChat invokes update_chat operation.
//
// Update Chat.
//
// PUT /api/v1/chat/{chat_id}
func (c *Client) UpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (UpdateChatRes, error) {
	res, err := c.sendUpdateChat(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (res UpdateChatRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chat/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEnvironmentUser invokes update_environment_user operation.
//
// Update an environment user's role.
//
// PUT /system/api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) UpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (UpdateEnvironmentUserRes, error) {
	res, err := c.sendUpdateEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (res UpdateEnvironmentUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/system/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOAuthService invokes update_oauth_service operation.
//
// Update Oauth Service.
//
// PUT /api/v1/oauth/services/{service_id}
func (c *Client) UpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (UpdateOAuthServiceRes, error) {
	res, err := c.sendUpdateOAuthService(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (res UpdateOAuthServiceRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOAuthServiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
