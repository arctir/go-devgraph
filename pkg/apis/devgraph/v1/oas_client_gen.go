// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// BulkInviteEnvironmentUsers invokes bulk_invite_environment_users operation.
	//
	// Bulk invite multiple users to an environment.
	//
	// POST /api/v1/environments/{environment_id}/users/bulk-invite
	BulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (BulkInviteEnvironmentUsersRes, error)
	// CheckEntitlement invokes check_entitlement operation.
	//
	// Check a specific entitlement for the authenticated user.
	//
	// GET /api/v1/entitlements/check/{entitlement_type}
	CheckEntitlement(ctx context.Context, params CheckEntitlementParams) (CheckEntitlementRes, error)
	// CleanupOrphanedEntities invokes cleanup_orphaned_entities operation.
	//
	// Delete all entities marked as orphans. Requires 'delete:entities' permission.
	//
	// DELETE /api/v1/entities/orphans
	CleanupOrphanedEntities(ctx context.Context, params CleanupOrphanedEntitiesParams) (CleanupOrphanedEntitiesRes, error)
	// CreateChat invokes create_chat operation.
	//
	// Create a new chat session.
	//
	// POST /api/v1/chats/
	CreateChat(ctx context.Context, request *ChatSessionCreate) (CreateChatRes, error)
	// CreateChatSuggestion invokes create_chat_suggestion operation.
	//
	// Create a new chat suggestion for the environment.
	//
	// POST /api/v1/chats/suggestions
	CreateChatSuggestion(ctx context.Context, request *ChatSuggestionCreate) (CreateChatSuggestionRes, error)
	// CreateChatTitle invokes create_chat_title operation.
	//
	// Generate a title for a chat based on the first message.
	//
	// POST /api/v1/chats/title
	CreateChatTitle(ctx context.Context, request *ChatTitleRequest) (CreateChatTitleRes, error)
	// CreateConfiguredProvider invokes create_configured_provider operation.
	//
	// Create a new configured discovery provider.
	// The provider configuration (including secrets) will be encrypted and stored.
	//
	// POST /api/v1/discovery/configured-providers
	CreateConfiguredProvider(ctx context.Context, request *ConfiguredProviderCreate) (CreateConfiguredProviderRes, error)
	// CreateEntitiesBulk invokes create_entities_bulk operation.
	//
	// Creates multiple entities in a single request with concurrent processing. Provides detailed
	// success/failure information for each entity. Requires 'create:entities' permission.
	//
	// POST /api/v1/entities/bulk
	CreateEntitiesBulk(ctx context.Context, request []Entity, params CreateEntitiesBulkParams) (CreateEntitiesBulkRes, error)
	// CreateEntity invokes create_entity operation.
	//
	// Creates a new entity based on the specified group, version, namespace, and kind. Requires
	// 'create:entities' permission.
	//
	// POST /api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}
	CreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (CreateEntityRes, error)
	// CreateEntityDefinition invokes create_entity_definition operation.
	//
	// Create a new entity definition with schema and storage configuration.
	//
	// POST /api/v1/entities/definitions
	CreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (CreateEntityDefinitionRes, error)
	// CreateEntityRelation invokes create_entity_relation operation.
	//
	// Create a relation between two entities in the knowledge graph.
	//
	// POST /api/v1/entities/relations
	CreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (CreateEntityRelationRes, error)
	// CreateEntityRelationsBulk invokes create_entity_relations_bulk operation.
	//
	// Creates multiple entity relations in a single request. Provides detailed success/failure
	// information for each relation. Requires 'create:entityrelations' permission.
	//
	// POST /api/v1/entities/relations/bulk
	CreateEntityRelationsBulk(ctx context.Context, request *BulkEntityRelationCreateRequest) (CreateEntityRelationsBulkRes, error)
	// CreateEnvironment invokes create_environment operation.
	//
	// Create a new environment with associated Clerk organization.
	//
	// POST /api/v1/environments
	CreateEnvironment(ctx context.Context, request *EnvironmentCreate) (CreateEnvironmentRes, error)
	// CreateEnvironmentUser invokes create_environment_user operation.
	//
	// Create a new environment user by adding them to the Clerk organization.
	//
	// POST /api/v1/environments/{environment_id}/users
	CreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (CreateEnvironmentUserRes, error)
	// CreateMcpToolAssociation invokes create_mcp_tool_association operation.
	//
	// Create an association between an MCP tool and an entity definition.
	//
	// POST /api/v1/mcp/tool-associations
	CreateMcpToolAssociation(ctx context.Context, request *MCPToolEntityAssociationCreate) (CreateMcpToolAssociationRes, error)
	// CreateMcpendpoint invokes create_mcpendpoint operation.
	//
	// Create a new MCP endpoint configuration.
	//
	// POST /api/v1/mcp/endpoints
	CreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (CreateMcpendpointRes, error)
	// CreateModel invokes create_model operation.
	//
	// Create a new AI model configuration with provider details in the environment.
	//
	// POST /api/v1/models
	CreateModel(ctx context.Context, request *ModelCreate) (CreateModelRes, error)
	// CreateModelprovider invokes create_modelprovider operation.
	//
	// Create a new model provider configuration.
	//
	// POST /api/v1/models/providers
	CreateModelprovider(ctx context.Context, request *ModelProviderCreate) (CreateModelproviderRes, error)
	// CreateOAuthService invokes create_oauth_service operation.
	//
	// Create a new OAuth service configuration.
	//
	// POST /api/v1/oauth/services
	CreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (CreateOAuthServiceRes, error)
	// CreatePrompt invokes create_prompt operation.
	//
	// Create a new prompt template in the environment.
	//
	// POST /api/v1/prompts
	CreatePrompt(ctx context.Context, request *PromptCreate) (CreatePromptRes, error)
	// CreateToken invokes create_token operation.
	//
	// Create a new API token for the authenticated user.
	//
	// POST /api/v1/tokens
	CreateToken(ctx context.Context, request *ApiTokenCreate) (CreateTokenRes, error)
	// DeleteChat invokes delete_chat operation.
	//
	// Delete a chat session by ID.
	//
	// DELETE /api/v1/chats/{chat_id}
	DeleteChat(ctx context.Context, params DeleteChatParams) (DeleteChatRes, error)
	// DeleteChatSuggestion invokes delete_chat_suggestion operation.
	//
	// Delete a chat suggestion owned by the user.
	//
	// DELETE /api/v1/chats/suggestions/{suggestion_id}
	DeleteChatSuggestion(ctx context.Context, params DeleteChatSuggestionParams) (DeleteChatSuggestionRes, error)
	// DeleteChatsBulk invokes delete_chats_bulk operation.
	//
	// Delete multiple chat sessions in bulk.
	//
	// DELETE /api/v1/chats/
	DeleteChatsBulk(ctx context.Context, request *BulkDeleteRequest) (DeleteChatsBulkRes, error)
	// DeleteConfiguredProvider invokes delete_configured_provider operation.
	//
	// Delete a configured discovery provider.
	//
	// DELETE /api/v1/discovery/configured-providers/{provider_id}
	DeleteConfiguredProvider(ctx context.Context, params DeleteConfiguredProviderParams) (DeleteConfiguredProviderRes, error)
	// DeleteEntity invokes delete_entity operation.
	//
	// Deletes a specific entity from the ontology. Requires 'delete:entities' permission.
	//
	// DELETE /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
	DeleteEntity(ctx context.Context, params DeleteEntityParams) (DeleteEntityRes, error)
	// DeleteEntityDefinition invokes delete_entity_definition operation.
	//
	// Delete an entity definition, all its versions, and optionally mark associated entities as orphans.
	//
	// DELETE /api/v1/entities/definitions/{definition_id}
	DeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (DeleteEntityDefinitionRes, error)
	// DeleteEntityRelation invokes delete_entity_relation operation.
	//
	// Deletes a specific relation between two entities. Requires 'delete:entityrelations' permission.
	//
	// DELETE /api/v1/entities/relations
	DeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (DeleteEntityRelationRes, error)
	// DeleteEnvironment invokes delete_environment operation.
	//
	// Delete an environment with grace period for recovery.
	//
	// DELETE /api/v1/environments/{env_id}
	DeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (DeleteEnvironmentRes, error)
	// DeleteEnvironmentInvitation invokes delete_environment_invitation operation.
	//
	// Revoke a pending invitation to an environment.
	//
	// DELETE /api/v1/environments/{environment_id}/users/invitations/{invitation_id}
	DeleteEnvironmentInvitation(ctx context.Context, params DeleteEnvironmentInvitationParams) (DeleteEnvironmentInvitationRes, error)
	// DeleteEnvironmentUser invokes delete_environment_user operation.
	//
	// Remove a user from an environment.
	//
	// DELETE /api/v1/environments/{environment_id}/users/{user_id}
	DeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (DeleteEnvironmentUserRes, error)
	// DeleteMcpToolAssociation invokes delete_mcp_tool_association operation.
	//
	// Delete an MCP tool-entity association.
	//
	// DELETE /api/v1/mcp/tool-associations/{association_id}
	DeleteMcpToolAssociation(ctx context.Context, params DeleteMcpToolAssociationParams) (DeleteMcpToolAssociationRes, error)
	// DeleteMcpendpoint invokes delete_mcpendpoint operation.
	//
	// Delete a specific MCP endpoint configuration by ID.
	//
	// DELETE /api/v1/mcp/endpoints/{mcpendpoint_id}
	DeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (DeleteMcpendpointRes, error)
	// DeleteModel invokes delete_model operation.
	//
	// Delete an AI model configuration by name.
	//
	// DELETE /api/v1/models/{model_name}
	DeleteModel(ctx context.Context, params DeleteModelParams) (DeleteModelRes, error)
	// DeleteModelprovider invokes delete_modelprovider operation.
	//
	// Delete a specific model provider configuration by ID.
	//
	// DELETE /api/v1/models/providers/{provider_id}
	DeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (DeleteModelproviderRes, error)
	// DeleteOAuthService invokes delete_oauth_service operation.
	//
	// Delete an OAuth service configuration.
	//
	// DELETE /api/v1/oauth/services/{service_id}
	DeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (DeleteOAuthServiceRes, error)
	// DeletePrompt invokes delete_prompt operation.
	//
	// Delete a prompt template by ID.
	//
	// DELETE /api/v1/prompts/{prompt_id}
	DeletePrompt(ctx context.Context, params DeletePromptParams) (DeletePromptRes, error)
	// DeleteToken invokes delete_token operation.
	//
	// Delete an API token.
	//
	// DELETE /api/v1/tokens/{token_id}
	DeleteToken(ctx context.Context, params DeleteTokenParams) (DeleteTokenRes, error)
	// ExchangeOAuthToken invokes exchange_oauth_token operation.
	//
	// Exchange an authorization code for an access token.
	//
	// POST /api/v1/oauth/token
	ExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (ExchangeOAuthTokenRes, error)
	// GetAllProviderVersions invokes get_all_provider_versions operation.
	//
	// Get version support info for all available provider types.
	//
	// GET /api/v1/discovery/versions
	GetAllProviderVersions(ctx context.Context) (GetAllProviderVersionsRes, error)
	// GetChat invokes get_chat operation.
	//
	// Retrieve a specific chat session by ID.
	//
	// GET /api/v1/chats/{chat_id}
	GetChat(ctx context.Context, params GetChatParams) (GetChatRes, error)
	// GetChatMessages invokes get_chat_messages operation.
	//
	// Retrieve all messages from a specific chat session.
	//
	// GET /api/v1/chats/{chat_id}/messages
	GetChatMessages(ctx context.Context, params GetChatMessagesParams) (GetChatMessagesRes, error)
	// GetChats invokes get_chats operation.
	//
	// List all chat sessions for the authenticated user.
	//
	// GET /api/v1/chats/
	GetChats(ctx context.Context, params GetChatsParams) (GetChatsRes, error)
	// GetConfiguredProvider invokes get_configured_provider operation.
	//
	// Get a specific configured discovery provider.
	// Secrets in the provider configuration are masked.
	//
	// GET /api/v1/discovery/configured-providers/{provider_id}
	GetConfiguredProvider(ctx context.Context, params GetConfiguredProviderParams) (GetConfiguredProviderRes, error)
	// GetDeprecatedProviderConfigs invokes get_deprecated_provider_configs operation.
	//
	// Get all provider instances using deprecated config versions.
	//
	// GET /api/v1/discovery/versions/deprecated
	GetDeprecatedProviderConfigs(ctx context.Context, params GetDeprecatedProviderConfigsParams) (GetDeprecatedProviderConfigsRes, error)
	// GetDiscoveryProviderConfigSchema invokes get_discovery_provider_config_schema operation.
	//
	// Get the configuration schema for a specific discovery provider type.
	//
	// GET /api/v1/discovery/providers/{provider_type}/config-schema
	GetDiscoveryProviderConfigSchema(ctx context.Context, params GetDiscoveryProviderConfigSchemaParams) (GetDiscoveryProviderConfigSchemaRes, error)
	// GetEntities invokes get_entities operation.
	//
	// Retrieves entities from the ontology, optionally filtered by field selectors. Field selectors use
	// dot notation for nested properties (e.g., 'spec.metadata.owner=team-a'). Requires 'read:entities'
	// permission.
	//
	// GET /api/v1/entities/
	GetEntities(ctx context.Context, params GetEntitiesParams) (GetEntitiesRes, error)
	// GetEntitlements invokes get_entitlements operation.
	//
	// Get all entitlements and current usage for the authenticated user.
	//
	// GET /api/v1/entitlements
	GetEntitlements(ctx context.Context) (GetEntitlementsRes, error)
	// GetEntity invokes get_entity operation.
	//
	// Fetches a specific entity based on group, version, namespace, plural, and name, including related
	// entities and relations. Requires 'read:entities' permission.
	//
	// GET /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
	GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error)
	// GetEntityByUID invokes get_entity_by_uid operation.
	//
	// Fetches a specific entity by its unique identifier (UID), including related entities and relations.
	//  Requires 'read:entities' permission.
	//
	// GET /api/v1/entities/uid/{uid}
	GetEntityByUID(ctx context.Context, params GetEntityByUIDParams) (GetEntityByUIDRes, error)
	// GetEntityDefinitions invokes get_entity_definitions operation.
	//
	// Fetches a list of all entity definitions with versions, ordered by group and kind.
	//
	// GET /api/v1/entities/definitions
	GetEntityDefinitions(ctx context.Context) (GetEntityDefinitionsRes, error)
	// GetEntityTools invokes get_entity_tools operation.
	//
	// Get all MCP tools associated with an entity definition.
	//
	// GET /api/v1/mcp/entity-definitions/{entity_definition_id}/tools
	GetEntityTools(ctx context.Context, params GetEntityToolsParams) (GetEntityToolsRes, error)
	// GetEnvironmentStatus invokes get_environment_status operation.
	//
	// Get Environment Status.
	//
	// GET /api/v1/environments/{env_id}/status
	GetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (GetEnvironmentStatusRes, error)
	// GetEnvironmentUser invokes get_environment_user operation.
	//
	// Get a specific environment user by ID.
	//
	// GET /api/v1/environments/{environment_id}/users/{user_id}
	GetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (GetEnvironmentUserRes, error)
	// GetEnvironments invokes get_environments operation.
	//
	// List all environments accessible to the authenticated user.
	//
	// GET /api/v1/environments
	GetEnvironments(ctx context.Context) (GetEnvironmentsRes, error)
	// GetMcpEndpointEntityTypes invokes get_mcp_endpoint_entity_types operation.
	//
	// Get all entity types associated with an MCP endpoint's tools.
	//
	// GET /api/v1/mcp/endpoints/{mcpendpoint_name}/entity-types
	GetMcpEndpointEntityTypes(ctx context.Context, params GetMcpEndpointEntityTypesParams) (GetMcpEndpointEntityTypesRes, error)
	// GetMcpendpoint invokes get_mcpendpoint operation.
	//
	// Get a specific MCP endpoint configuration by ID.
	//
	// GET /api/v1/mcp/endpoints/{mcpendpoint_id}
	GetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (GetMcpendpointRes, error)
	// GetMcpendpoints invokes get_mcpendpoints operation.
	//
	// List all MCP endpoint configurations for the authenticated user and environment.
	//
	// GET /api/v1/mcp/endpoints
	GetMcpendpoints(ctx context.Context) (GetMcpendpointsRes, error)
	// GetModel invokes get_model operation.
	//
	// Retrieve a specific AI model configuration by name.
	//
	// GET /api/v1/models/{model_name}
	GetModel(ctx context.Context, params GetModelParams) (GetModelRes, error)
	// GetModelprovider invokes get_modelprovider operation.
	//
	// Get a specific model provider configuration by ID.
	//
	// GET /api/v1/models/providers/{provider_id}
	GetModelprovider(ctx context.Context, params GetModelproviderParams) (GetModelproviderRes, error)
	// GetModelproviders invokes get_modelproviders operation.
	//
	// List all model provider configurations for the authenticated user and environment.
	//
	// GET /api/v1/models/providers
	GetModelproviders(ctx context.Context) (GetModelprovidersRes, error)
	// GetModels invokes get_models operation.
	//
	// Retrieve all AI model configurations for the current environment.
	//
	// GET /api/v1/models
	GetModels(ctx context.Context) (GetModelsRes, error)
	// GetOAuthAuthorizationURL invokes get_oauth_authorization_url operation.
	//
	// Generate an OAuth authorization URL for a service.
	//
	// POST /api/v1/oauth/authorize
	GetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (GetOAuthAuthorizationURLRes, error)
	// GetOAuthService invokes get_oauth_service operation.
	//
	// Get a specific OAuth service configuration by ID.
	//
	// GET /api/v1/oauth/services/{service_id}
	GetOAuthService(ctx context.Context, params GetOAuthServiceParams) (GetOAuthServiceRes, error)
	// GetPendingInvitations invokes get_pending_invitations operation.
	//
	// Get all pending invitations for an environment.
	//
	// GET /api/v1/environments/{environment_id}/users/pending
	GetPendingInvitations(ctx context.Context, params GetPendingInvitationsParams) (GetPendingInvitationsRes, error)
	// GetPrompt invokes get_prompt operation.
	//
	// Retrieve a specific prompt template by ID.
	//
	// GET /api/v1/prompts/{prompt_id}
	GetPrompt(ctx context.Context, params GetPromptParams) (GetPromptRes, error)
	// GetSubscriptions invokes get_subscriptions operation.
	//
	// List all subscriptions for the authenticated user.
	//
	// GET /api/v1/subscriptions
	GetSubscriptions(ctx context.Context) (GetSubscriptionsRes, error)
	// GetSystemDefaultPrompt invokes get_system_default_prompt operation.
	//
	// Retrieve the system default prompt template.
	//
	// GET /api/v1/prompts/system-default
	GetSystemDefaultPrompt(ctx context.Context) (GetSystemDefaultPromptRes, error)
	// GetTokens invokes get_tokens operation.
	//
	// List all API tokens for the authenticated user.
	//
	// GET /api/v1/tokens
	GetTokens(ctx context.Context) (GetTokensRes, error)
	// InviteEnvironmentUser invokes invite_environment_user operation.
	//
	// Invite a user to an environment.
	//
	// POST /api/v1/environments/{environment_id}/users/invite
	InviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (InviteEnvironmentUserRes, error)
	// ListChatSuggestions invokes list_chat_suggestions operation.
	//
	// List chat suggestions including system-wide and user-specific ones.
	//
	// GET /api/v1/chats/suggestions
	ListChatSuggestions(ctx context.Context, params ListChatSuggestionsParams) (ListChatSuggestionsRes, error)
	// ListConfiguredProviders invokes list_configured_providers operation.
	//
	// List all configured discovery providers for the current environment.
	// Secrets in provider configurations are masked.
	//
	// GET /api/v1/discovery/configured-providers
	ListConfiguredProviders(ctx context.Context) (ListConfiguredProvidersRes, error)
	// ListDiscoveryProviders invokes list_discovery_providers operation.
	//
	// List all available discovery provider types with their configuration schemas.
	//
	// GET /api/v1/discovery/providers
	ListDiscoveryProviders(ctx context.Context) (ListDiscoveryProvidersRes, error)
	// ListEnvironmentUsers invokes list_environment_users operation.
	//
	// List all users in an environment.
	//
	// GET /api/v1/environments/{environment_id}/users
	ListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (ListEnvironmentUsersRes, error)
	// ListMcpendpointTools invokes list_mcpendpoint_tools operation.
	//
	// List all available tools from a specific MCP endpoint.
	//
	// GET /api/v1/mcp/endpoints/{mcpendpoint_id}/tools
	ListMcpendpointTools(ctx context.Context, params ListMcpendpointToolsParams) (ListMcpendpointToolsRes, error)
	// ListOAuthServices invokes list_oauth_services operation.
	//
	// List all OAuth service configurations.
	//
	// GET /api/v1/oauth/services
	ListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (ListOAuthServicesRes, error)
	// ListOAuthTokens invokes list_oauth_tokens operation.
	//
	// List all OAuth tokens for the authenticated user.
	//
	// GET /api/v1/oauth/tokens
	ListOAuthTokens(ctx context.Context) (ListOAuthTokensRes, error)
	// ListOrphanedEntities invokes list_orphaned_entities operation.
	//
	// Lists all entities marked as orphans across all namespaces. Requires 'read:entities' permission.
	//
	// GET /api/v1/entities/orphans
	ListOrphanedEntities(ctx context.Context, params ListOrphanedEntitiesParams) (ListOrphanedEntitiesRes, error)
	// ListPrompts invokes list_prompts operation.
	//
	// List all prompt templates for the environment, optionally filtered by active status.
	//
	// GET /api/v1/prompts
	ListPrompts(ctx context.Context, params ListPromptsParams) (ListPromptsRes, error)
	// MigrateAllDeprecatedConfigs invokes migrate_all_deprecated_configs operation.
	//
	// Batch migrate all configs using deprecated versions.
	//
	// POST /api/v1/discovery/versions/migrate-all
	MigrateAllDeprecatedConfigs(ctx context.Context, params MigrateAllDeprecatedConfigsParams) (MigrateAllDeprecatedConfigsRes, error)
	// MigrateProviderConfig invokes migrate_provider_config operation.
	//
	// Migrate a specific provider config to the latest version.
	//
	// POST /api/v1/discovery/versions/{provider_id}/migrate
	MigrateProviderConfig(ctx context.Context, params MigrateProviderConfigParams) (MigrateProviderConfigRes, error)
	// PostChatMessages invokes post_chat_messages operation.
	//
	// Add one or more messages to a chat session.
	//
	// POST /api/v1/chats/{chat_id}/messages
	PostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (PostChatMessagesRes, error)
	// RevokeOAuthToken invokes revoke_oauth_token operation.
	//
	// Revoke an OAuth token for a service.
	//
	// DELETE /api/v1/oauth/tokens/{service_name}
	RevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (RevokeOAuthTokenRes, error)
	// UpdateChat invokes update_chat operation.
	//
	// Update an existing chat session.
	//
	// PUT /api/v1/chats/{chat_id}
	UpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (UpdateChatRes, error)
	// UpdateConfiguredProvider invokes update_configured_provider operation.
	//
	// Update a configured discovery provider.
	// Only provided fields will be updated. To update secrets, provide the full
	// config object with new secret values.
	//
	// PUT /api/v1/discovery/configured-providers/{provider_id}
	UpdateConfiguredProvider(ctx context.Context, request *ConfiguredProviderUpdate, params UpdateConfiguredProviderParams) (UpdateConfiguredProviderRes, error)
	// UpdateEnvironmentUser invokes update_environment_user operation.
	//
	// Update an environment user's role.
	//
	// PUT /api/v1/environments/{environment_id}/users/{user_id}
	UpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (UpdateEnvironmentUserRes, error)
	// UpdateMcpendpoint invokes update_mcpendpoint operation.
	//
	// Update a specific MCP endpoint configuration by ID.
	//
	// PUT /api/v1/mcp/endpoints/{mcpendpoint_id}
	UpdateMcpendpoint(ctx context.Context, request *MCPEndpointUpdate, params UpdateMcpendpointParams) (UpdateMcpendpointRes, error)
	// UpdateModel invokes update_model operation.
	//
	// Update an existing AI model configuration by name.
	//
	// PUT /api/v1/models/{model_name}
	UpdateModel(ctx context.Context, request *ModelUpdate, params UpdateModelParams) (UpdateModelRes, error)
	// UpdateModelprovider invokes update_modelprovider operation.
	//
	// Update a specific model provider configuration by ID.
	//
	// PUT /api/v1/models/providers/{provider_id}
	UpdateModelprovider(ctx context.Context, request *ModelProviderUpdate, params UpdateModelproviderParams) (UpdateModelproviderRes, error)
	// UpdateOAuthService invokes update_oauth_service operation.
	//
	// Update an existing OAuth service configuration.
	//
	// PUT /api/v1/oauth/services/{service_id}
	UpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (UpdateOAuthServiceRes, error)
	// UpdatePrompt invokes update_prompt operation.
	//
	// Update an existing prompt template by ID.
	//
	// PUT /api/v1/prompts/{prompt_id}
	UpdatePrompt(ctx context.Context, request *PromptUpdate, params UpdatePromptParams) (UpdatePromptRes, error)
	// UpdateToken invokes update_token operation.
	//
	// Update an existing API token.
	//
	// PUT /api/v1/tokens/{token_id}
	UpdateToken(ctx context.Context, request *ApiTokenUpdate, params UpdateTokenParams) (UpdateTokenRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// BulkInviteEnvironmentUsers invokes bulk_invite_environment_users operation.
//
// Bulk invite multiple users to an environment.
//
// POST /api/v1/environments/{environment_id}/users/bulk-invite
func (c *Client) BulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (BulkInviteEnvironmentUsersRes, error) {
	res, err := c.sendBulkInviteEnvironmentUsers(ctx, request, params)
	return res, err
}

func (c *Client) sendBulkInviteEnvironmentUsers(ctx context.Context, request *EnvironmentUserBulkInvite, params BulkInviteEnvironmentUsersParams) (res BulkInviteEnvironmentUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("bulk_invite_environment_users"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/bulk-invite"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BulkInviteEnvironmentUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/bulk-invite"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeBulkInviteEnvironmentUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, BulkInviteEnvironmentUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeBulkInviteEnvironmentUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CheckEntitlement invokes check_entitlement operation.
//
// Check a specific entitlement for the authenticated user.
//
// GET /api/v1/entitlements/check/{entitlement_type}
func (c *Client) CheckEntitlement(ctx context.Context, params CheckEntitlementParams) (CheckEntitlementRes, error) {
	res, err := c.sendCheckEntitlement(ctx, params)
	return res, err
}

func (c *Client) sendCheckEntitlement(ctx context.Context, params CheckEntitlementParams) (res CheckEntitlementRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("check_entitlement"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entitlements/check/{entitlement_type}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CheckEntitlementOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/entitlements/check/"
	{
		// Encode "entitlement_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entitlement_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EntitlementType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CheckEntitlementOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCheckEntitlementResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CleanupOrphanedEntities invokes cleanup_orphaned_entities operation.
//
// Delete all entities marked as orphans. Requires 'delete:entities' permission.
//
// DELETE /api/v1/entities/orphans
func (c *Client) CleanupOrphanedEntities(ctx context.Context, params CleanupOrphanedEntitiesParams) (CleanupOrphanedEntitiesRes, error) {
	res, err := c.sendCleanupOrphanedEntities(ctx, params)
	return res, err
}

func (c *Client) sendCleanupOrphanedEntities(ctx context.Context, params CleanupOrphanedEntitiesParams) (res CleanupOrphanedEntitiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("cleanup_orphaned_entities"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/entities/orphans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CleanupOrphanedEntitiesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/orphans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Namespace.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "max_age_hours" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "max_age_hours",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MaxAgeHours.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CleanupOrphanedEntitiesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCleanupOrphanedEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChat invokes create_chat operation.
//
// Create a new chat session.
//
// POST /api/v1/chats/
func (c *Client) CreateChat(ctx context.Context, request *ChatSessionCreate) (CreateChatRes, error) {
	res, err := c.sendCreateChat(ctx, request)
	return res, err
}

func (c *Client) sendCreateChat(ctx context.Context, request *ChatSessionCreate) (res CreateChatRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_chat"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/chats/"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatSuggestion invokes create_chat_suggestion operation.
//
// Create a new chat suggestion for the environment.
//
// POST /api/v1/chats/suggestions
func (c *Client) CreateChatSuggestion(ctx context.Context, request *ChatSuggestionCreate) (CreateChatSuggestionRes, error) {
	res, err := c.sendCreateChatSuggestion(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatSuggestion(ctx context.Context, request *ChatSuggestionCreate) (res CreateChatSuggestionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_chat_suggestion"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/chats/suggestions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatSuggestionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/suggestions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatSuggestionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateChatSuggestionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatSuggestionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChatTitle invokes create_chat_title operation.
//
// Generate a title for a chat based on the first message.
//
// POST /api/v1/chats/title
func (c *Client) CreateChatTitle(ctx context.Context, request *ChatTitleRequest) (CreateChatTitleRes, error) {
	res, err := c.sendCreateChatTitle(ctx, request)
	return res, err
}

func (c *Client) sendCreateChatTitle(ctx context.Context, request *ChatTitleRequest) (res CreateChatTitleRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_chat_title"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/chats/title"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateChatTitleOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/title"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChatTitleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateChatTitleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateChatTitleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateConfiguredProvider invokes create_configured_provider operation.
//
// Create a new configured discovery provider.
// The provider configuration (including secrets) will be encrypted and stored.
//
// POST /api/v1/discovery/configured-providers
func (c *Client) CreateConfiguredProvider(ctx context.Context, request *ConfiguredProviderCreate) (CreateConfiguredProviderRes, error) {
	res, err := c.sendCreateConfiguredProvider(ctx, request)
	return res, err
}

func (c *Client) sendCreateConfiguredProvider(ctx context.Context, request *ConfiguredProviderCreate) (res CreateConfiguredProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_configured_provider"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/discovery/configured-providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateConfiguredProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/configured-providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateConfiguredProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateConfiguredProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateConfiguredProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntitiesBulk invokes create_entities_bulk operation.
//
// Creates multiple entities in a single request with concurrent processing. Provides detailed
// success/failure information for each entity. Requires 'create:entities' permission.
//
// POST /api/v1/entities/bulk
func (c *Client) CreateEntitiesBulk(ctx context.Context, request []Entity, params CreateEntitiesBulkParams) (CreateEntitiesBulkRes, error) {
	res, err := c.sendCreateEntitiesBulk(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEntitiesBulk(ctx context.Context, request []Entity, params CreateEntitiesBulkParams) (res CreateEntitiesBulkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_entities_bulk"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/entities/bulk"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEntitiesBulkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/bulk"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "version" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "plural" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "plural",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Plural))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntitiesBulkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntitiesBulkOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEntitiesBulkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntity invokes create_entity operation.
//
// Creates a new entity based on the specified group, version, namespace, and kind. Requires
// 'create:entities' permission.
//
// POST /api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}
func (c *Client) CreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (CreateEntityRes, error) {
	res, err := c.sendCreateEntity(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEntity(ctx context.Context, request *Entity, params CreateEntityParams) (res CreateEntityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_entity"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/entities/{group}/{version}/namespace/{namespace}/{plural}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEntityOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [8]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/namespace/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "plural" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "plural",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Plural))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntityDefinition invokes create_entity_definition operation.
//
// Create a new entity definition with schema and storage configuration.
//
// POST /api/v1/entities/definitions
func (c *Client) CreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (CreateEntityDefinitionRes, error) {
	res, err := c.sendCreateEntityDefinition(ctx, request)
	return res, err
}

func (c *Client) sendCreateEntityDefinition(ctx context.Context, request *EntityDefinitionSpec) (res CreateEntityDefinitionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_entity_definition"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/entities/definitions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEntityDefinitionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/definitions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityDefinitionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityDefinitionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEntityDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntityRelation invokes create_entity_relation operation.
//
// Create a relation between two entities in the knowledge graph.
//
// POST /api/v1/entities/relations
func (c *Client) CreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (CreateEntityRelationRes, error) {
	res, err := c.sendCreateEntityRelation(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEntityRelation(ctx context.Context, request *EntityRelation, params CreateEntityRelationParams) (res CreateEntityRelationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_entity_relation"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/entities/relations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEntityRelationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/relations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityRelationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityRelationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEntityRelationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEntityRelationsBulk invokes create_entity_relations_bulk operation.
//
// Creates multiple entity relations in a single request. Provides detailed success/failure
// information for each relation. Requires 'create:entityrelations' permission.
//
// POST /api/v1/entities/relations/bulk
func (c *Client) CreateEntityRelationsBulk(ctx context.Context, request *BulkEntityRelationCreateRequest) (CreateEntityRelationsBulkRes, error) {
	res, err := c.sendCreateEntityRelationsBulk(ctx, request)
	return res, err
}

func (c *Client) sendCreateEntityRelationsBulk(ctx context.Context, request *BulkEntityRelationCreateRequest) (res CreateEntityRelationsBulkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_entity_relations_bulk"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/entities/relations/bulk"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEntityRelationsBulkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/relations/bulk"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEntityRelationsBulkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEntityRelationsBulkOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEntityRelationsBulkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironment invokes create_environment operation.
//
// Create a new environment with associated Clerk organization.
//
// POST /api/v1/environments
func (c *Client) CreateEnvironment(ctx context.Context, request *EnvironmentCreate) (CreateEnvironmentRes, error) {
	res, err := c.sendCreateEnvironment(ctx, request)
	return res, err
}

func (c *Client) sendCreateEnvironment(ctx context.Context, request *EnvironmentCreate) (res CreateEnvironmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_environment"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/environments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEnvironmentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEnvironmentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironmentUser invokes create_environment_user operation.
//
// Create a new environment user by adding them to the Clerk organization.
//
// POST /api/v1/environments/{environment_id}/users
func (c *Client) CreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (CreateEnvironmentUserRes, error) {
	res, err := c.sendCreateEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEnvironmentUser(ctx context.Context, request *EnvironmentUserCreate, params CreateEnvironmentUserParams) (res CreateEnvironmentUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_environment_user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateEnvironmentUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMcpToolAssociation invokes create_mcp_tool_association operation.
//
// Create an association between an MCP tool and an entity definition.
//
// POST /api/v1/mcp/tool-associations
func (c *Client) CreateMcpToolAssociation(ctx context.Context, request *MCPToolEntityAssociationCreate) (CreateMcpToolAssociationRes, error) {
	res, err := c.sendCreateMcpToolAssociation(ctx, request)
	return res, err
}

func (c *Client) sendCreateMcpToolAssociation(ctx context.Context, request *MCPToolEntityAssociationCreate) (res CreateMcpToolAssociationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_mcp_tool_association"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/mcp/tool-associations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateMcpToolAssociationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/mcp/tool-associations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMcpToolAssociationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateMcpToolAssociationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateMcpToolAssociationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateMcpendpoint invokes create_mcpendpoint operation.
//
// Create a new MCP endpoint configuration.
//
// POST /api/v1/mcp/endpoints
func (c *Client) CreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (CreateMcpendpointRes, error) {
	res, err := c.sendCreateMcpendpoint(ctx, request)
	return res, err
}

func (c *Client) sendCreateMcpendpoint(ctx context.Context, request *MCPEndpointCreate) (res CreateMcpendpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_mcpendpoint"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateMcpendpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/mcp/endpoints"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateMcpendpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateModel invokes create_model operation.
//
// Create a new AI model configuration with provider details in the environment.
//
// POST /api/v1/models
func (c *Client) CreateModel(ctx context.Context, request *ModelCreate) (CreateModelRes, error) {
	res, err := c.sendCreateModel(ctx, request)
	return res, err
}

func (c *Client) sendCreateModel(ctx context.Context, request *ModelCreate) (res CreateModelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_model"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/models"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateModelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/models"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateModelprovider invokes create_modelprovider operation.
//
// Create a new model provider configuration.
//
// POST /api/v1/models/providers
func (c *Client) CreateModelprovider(ctx context.Context, request *ModelProviderCreate) (CreateModelproviderRes, error) {
	res, err := c.sendCreateModelprovider(ctx, request)
	return res, err
}

func (c *Client) sendCreateModelprovider(ctx context.Context, request *ModelProviderCreate) (res CreateModelproviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_modelprovider"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/models/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateModelproviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/models/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateModelproviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOAuthService invokes create_oauth_service operation.
//
// Create a new OAuth service configuration.
//
// POST /api/v1/oauth/services
func (c *Client) CreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (CreateOAuthServiceRes, error) {
	res, err := c.sendCreateOAuthService(ctx, request)
	return res, err
}

func (c *Client) sendCreateOAuthService(ctx context.Context, request *OAuthServiceCreate) (res CreateOAuthServiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_oauth_service"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/oauth/services"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateOAuthServiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/services"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOAuthServiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePrompt invokes create_prompt operation.
//
// Create a new prompt template in the environment.
//
// POST /api/v1/prompts
func (c *Client) CreatePrompt(ctx context.Context, request *PromptCreate) (CreatePromptRes, error) {
	res, err := c.sendCreatePrompt(ctx, request)
	return res, err
}

func (c *Client) sendCreatePrompt(ctx context.Context, request *PromptCreate) (res CreatePromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_prompt"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreatePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePromptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreatePromptOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreatePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateToken invokes create_token operation.
//
// Create a new API token for the authenticated user.
//
// POST /api/v1/tokens
func (c *Client) CreateToken(ctx context.Context, request *ApiTokenCreate) (CreateTokenRes, error) {
	res, err := c.sendCreateToken(ctx, request)
	return res, err
}

func (c *Client) sendCreateToken(ctx context.Context, request *ApiTokenCreate) (res CreateTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("create_token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/tokens"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, CreateTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChat invokes delete_chat operation.
//
// Delete a chat session by ID.
//
// DELETE /api/v1/chats/{chat_id}
func (c *Client) DeleteChat(ctx context.Context, params DeleteChatParams) (DeleteChatRes, error) {
	res, err := c.sendDeleteChat(ctx, params)
	return res, err
}

func (c *Client) sendDeleteChat(ctx context.Context, params DeleteChatParams) (res DeleteChatRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_chat"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/chats/{chat_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chats/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatSuggestion invokes delete_chat_suggestion operation.
//
// Delete a chat suggestion owned by the user.
//
// DELETE /api/v1/chats/suggestions/{suggestion_id}
func (c *Client) DeleteChatSuggestion(ctx context.Context, params DeleteChatSuggestionParams) (DeleteChatSuggestionRes, error) {
	res, err := c.sendDeleteChatSuggestion(ctx, params)
	return res, err
}

func (c *Client) sendDeleteChatSuggestion(ctx context.Context, params DeleteChatSuggestionParams) (res DeleteChatSuggestionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_chat_suggestion"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/chats/suggestions/{suggestion_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatSuggestionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chats/suggestions/"
	{
		// Encode "suggestion_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "suggestion_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SuggestionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteChatSuggestionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatSuggestionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteChatsBulk invokes delete_chats_bulk operation.
//
// Delete multiple chat sessions in bulk.
//
// DELETE /api/v1/chats/
func (c *Client) DeleteChatsBulk(ctx context.Context, request *BulkDeleteRequest) (DeleteChatsBulkRes, error) {
	res, err := c.sendDeleteChatsBulk(ctx, request)
	return res, err
}

func (c *Client) sendDeleteChatsBulk(ctx context.Context, request *BulkDeleteRequest) (res DeleteChatsBulkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_chats_bulk"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/chats/"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteChatsBulkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteChatsBulkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteChatsBulkOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteChatsBulkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteConfiguredProvider invokes delete_configured_provider operation.
//
// Delete a configured discovery provider.
//
// DELETE /api/v1/discovery/configured-providers/{provider_id}
func (c *Client) DeleteConfiguredProvider(ctx context.Context, params DeleteConfiguredProviderParams) (DeleteConfiguredProviderRes, error) {
	res, err := c.sendDeleteConfiguredProvider(ctx, params)
	return res, err
}

func (c *Client) sendDeleteConfiguredProvider(ctx context.Context, params DeleteConfiguredProviderParams) (res DeleteConfiguredProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_configured_provider"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/discovery/configured-providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteConfiguredProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/discovery/configured-providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteConfiguredProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteConfiguredProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntity invokes delete_entity operation.
//
// Deletes a specific entity from the ontology. Requires 'delete:entities' permission.
//
// DELETE /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
func (c *Client) DeleteEntity(ctx context.Context, params DeleteEntityParams) (DeleteEntityRes, error) {
	res, err := c.sendDeleteEntity(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEntity(ctx context.Context, params DeleteEntityParams) (res DeleteEntityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_entity"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEntityOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [10]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "kind" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kind",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Kind))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[9] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntityDefinition invokes delete_entity_definition operation.
//
// Delete an entity definition, all its versions, and optionally mark associated entities as orphans.
//
// DELETE /api/v1/entities/definitions/{definition_id}
func (c *Client) DeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (DeleteEntityDefinitionRes, error) {
	res, err := c.sendDeleteEntityDefinition(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEntityDefinition(ctx context.Context, params DeleteEntityDefinitionParams) (res DeleteEntityDefinitionRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_entity_definition"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/entities/definitions/{definition_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEntityDefinitionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/entities/definitions/"
	{
		// Encode "definition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "definition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.DefinitionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "mark_orphans_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mark_orphans_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.MarkOrphansOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityDefinitionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEntityDefinitionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEntityRelation invokes delete_entity_relation operation.
//
// Deletes a specific relation between two entities. Requires 'delete:entityrelations' permission.
//
// DELETE /api/v1/entities/relations
func (c *Client) DeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (DeleteEntityRelationRes, error) {
	res, err := c.sendDeleteEntityRelation(ctx, request, params)
	return res, err
}

func (c *Client) sendDeleteEntityRelation(ctx context.Context, request *EntityRelation, params DeleteEntityRelationParams) (res DeleteEntityRelationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_entity_relation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/entities/relations"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEntityRelationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/relations"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDeleteEntityRelationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEntityRelationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEntityRelationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEnvironment invokes delete_environment operation.
//
// Delete an environment with grace period for recovery.
//
// DELETE /api/v1/environments/{env_id}
func (c *Client) DeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (DeleteEnvironmentRes, error) {
	res, err := c.sendDeleteEnvironment(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (res DeleteEnvironmentRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_environment"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/environments/{env_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEnvironmentOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "env_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "env_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEnvironmentOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEnvironmentInvitation invokes delete_environment_invitation operation.
//
// Revoke a pending invitation to an environment.
//
// DELETE /api/v1/environments/{environment_id}/users/invitations/{invitation_id}
func (c *Client) DeleteEnvironmentInvitation(ctx context.Context, params DeleteEnvironmentInvitationParams) (DeleteEnvironmentInvitationRes, error) {
	res, err := c.sendDeleteEnvironmentInvitation(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEnvironmentInvitation(ctx context.Context, params DeleteEnvironmentInvitationParams) (res DeleteEnvironmentInvitationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_environment_invitation"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/invitations/{invitation_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEnvironmentInvitationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/invitations/"
	{
		// Encode "invitation_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invitation_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InvitationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEnvironmentInvitationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEnvironmentInvitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEnvironmentUser invokes delete_environment_user operation.
//
// Remove a user from an environment.
//
// DELETE /api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) DeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (DeleteEnvironmentUserRes, error) {
	res, err := c.sendDeleteEnvironmentUser(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEnvironmentUser(ctx context.Context, params DeleteEnvironmentUserParams) (res DeleteEnvironmentUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_environment_user"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/{user_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteEnvironmentUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMcpToolAssociation invokes delete_mcp_tool_association operation.
//
// Delete an MCP tool-entity association.
//
// DELETE /api/v1/mcp/tool-associations/{association_id}
func (c *Client) DeleteMcpToolAssociation(ctx context.Context, params DeleteMcpToolAssociationParams) (DeleteMcpToolAssociationRes, error) {
	res, err := c.sendDeleteMcpToolAssociation(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMcpToolAssociation(ctx context.Context, params DeleteMcpToolAssociationParams) (res DeleteMcpToolAssociationRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_mcp_tool_association"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/mcp/tool-associations/{association_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMcpToolAssociationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/mcp/tool-associations/"
	{
		// Encode "association_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "association_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.AssociationID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteMcpToolAssociationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMcpToolAssociationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMcpendpoint invokes delete_mcpendpoint operation.
//
// Delete a specific MCP endpoint configuration by ID.
//
// DELETE /api/v1/mcp/endpoints/{mcpendpoint_id}
func (c *Client) DeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (DeleteMcpendpointRes, error) {
	res, err := c.sendDeleteMcpendpoint(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMcpendpoint(ctx context.Context, params DeleteMcpendpointParams) (res DeleteMcpendpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_mcpendpoint"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints/{mcpendpoint_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteMcpendpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/mcp/endpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteModel invokes delete_model operation.
//
// Delete an AI model configuration by name.
//
// DELETE /api/v1/models/{model_name}
func (c *Client) DeleteModel(ctx context.Context, params DeleteModelParams) (DeleteModelRes, error) {
	res, err := c.sendDeleteModel(ctx, params)
	return res, err
}

func (c *Client) sendDeleteModel(ctx context.Context, params DeleteModelParams) (res DeleteModelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_model"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/models/{model_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteModelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/"
	{
		// Encode "model_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteModelprovider invokes delete_modelprovider operation.
//
// Delete a specific model provider configuration by ID.
//
// DELETE /api/v1/models/providers/{provider_id}
func (c *Client) DeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (DeleteModelproviderRes, error) {
	res, err := c.sendDeleteModelprovider(ctx, params)
	return res, err
}

func (c *Client) sendDeleteModelprovider(ctx context.Context, params DeleteModelproviderParams) (res DeleteModelproviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_modelprovider"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/models/providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteModelproviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOAuthService invokes delete_oauth_service operation.
//
// Delete an OAuth service configuration.
//
// DELETE /api/v1/oauth/services/{service_id}
func (c *Client) DeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (DeleteOAuthServiceRes, error) {
	res, err := c.sendDeleteOAuthService(ctx, params)
	return res, err
}

func (c *Client) sendDeleteOAuthService(ctx context.Context, params DeleteOAuthServiceParams) (res DeleteOAuthServiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_oauth_service"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/oauth/services/{service_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteOAuthServiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePrompt invokes delete_prompt operation.
//
// Delete a prompt template by ID.
//
// DELETE /api/v1/prompts/{prompt_id}
func (c *Client) DeletePrompt(ctx context.Context, params DeletePromptParams) (DeletePromptRes, error) {
	res, err := c.sendDeletePrompt(ctx, params)
	return res, err
}

func (c *Client) sendDeletePrompt(ctx context.Context, params DeletePromptParams) (res DeletePromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_prompt"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/prompts/{prompt_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeletePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/prompts/"
	{
		// Encode "prompt_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PromptID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeletePromptOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeletePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteToken invokes delete_token operation.
//
// Delete an API token.
//
// DELETE /api/v1/tokens/{token_id}
func (c *Client) DeleteToken(ctx context.Context, params DeleteTokenParams) (DeleteTokenRes, error) {
	res, err := c.sendDeleteToken(ctx, params)
	return res, err
}

func (c *Client) sendDeleteToken(ctx context.Context, params DeleteTokenParams) (res DeleteTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("delete_token"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/tokens/{token_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, DeleteTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/tokens/"
	{
		// Encode "token_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "token_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, DeleteTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeDeleteTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExchangeOAuthToken invokes exchange_oauth_token operation.
//
// Exchange an authorization code for an access token.
//
// POST /api/v1/oauth/token
func (c *Client) ExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (ExchangeOAuthTokenRes, error) {
	res, err := c.sendExchangeOAuthToken(ctx, request)
	return res, err
}

func (c *Client) sendExchangeOAuthToken(ctx context.Context, request *OAuthTokenExchange) (res ExchangeOAuthTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("exchange_oauth_token"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/oauth/token"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExchangeOAuthTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/token"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExchangeOAuthTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ExchangeOAuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeExchangeOAuthTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAllProviderVersions invokes get_all_provider_versions operation.
//
// Get version support info for all available provider types.
//
// GET /api/v1/discovery/versions
func (c *Client) GetAllProviderVersions(ctx context.Context) (GetAllProviderVersionsRes, error) {
	res, err := c.sendGetAllProviderVersions(ctx)
	return res, err
}

func (c *Client) sendGetAllProviderVersions(ctx context.Context) (res GetAllProviderVersionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_all_provider_versions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/versions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetAllProviderVersionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/versions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetAllProviderVersionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetAllProviderVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChat invokes get_chat operation.
//
// Retrieve a specific chat session by ID.
//
// GET /api/v1/chats/{chat_id}
func (c *Client) GetChat(ctx context.Context, params GetChatParams) (GetChatRes, error) {
	res, err := c.sendGetChat(ctx, params)
	return res, err
}

func (c *Client) sendGetChat(ctx context.Context, params GetChatParams) (res GetChatRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chat"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/chats/{chat_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chats/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChatMessages invokes get_chat_messages operation.
//
// Retrieve all messages from a specific chat session.
//
// GET /api/v1/chats/{chat_id}/messages
func (c *Client) GetChatMessages(ctx context.Context, params GetChatMessagesParams) (GetChatMessagesRes, error) {
	res, err := c.sendGetChatMessages(ctx, params)
	return res, err
}

func (c *Client) sendGetChatMessages(ctx context.Context, params GetChatMessagesParams) (res GetChatMessagesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chat_messages"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/chats/{chat_id}/messages"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/chats/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChats invokes get_chats operation.
//
// List all chat sessions for the authenticated user.
//
// GET /api/v1/chats/
func (c *Client) GetChats(ctx context.Context, params GetChatsParams) (GetChatsRes, error) {
	res, err := c.sendGetChats(ctx, params)
	return res, err
}

func (c *Client) sendGetChats(ctx context.Context, params GetChatsParams) (res GetChatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_chats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/chats/"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetChatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetChatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetChatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConfiguredProvider invokes get_configured_provider operation.
//
// Get a specific configured discovery provider.
// Secrets in the provider configuration are masked.
//
// GET /api/v1/discovery/configured-providers/{provider_id}
func (c *Client) GetConfiguredProvider(ctx context.Context, params GetConfiguredProviderParams) (GetConfiguredProviderRes, error) {
	res, err := c.sendGetConfiguredProvider(ctx, params)
	return res, err
}

func (c *Client) sendGetConfiguredProvider(ctx context.Context, params GetConfiguredProviderParams) (res GetConfiguredProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_configured_provider"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/configured-providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConfiguredProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/discovery/configured-providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetConfiguredProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConfiguredProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDeprecatedProviderConfigs invokes get_deprecated_provider_configs operation.
//
// Get all provider instances using deprecated config versions.
//
// GET /api/v1/discovery/versions/deprecated
func (c *Client) GetDeprecatedProviderConfigs(ctx context.Context, params GetDeprecatedProviderConfigsParams) (GetDeprecatedProviderConfigsRes, error) {
	res, err := c.sendGetDeprecatedProviderConfigs(ctx, params)
	return res, err
}

func (c *Client) sendGetDeprecatedProviderConfigs(ctx context.Context, params GetDeprecatedProviderConfigsParams) (res GetDeprecatedProviderConfigsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_deprecated_provider_configs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/versions/deprecated"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDeprecatedProviderConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/versions/deprecated"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "environment_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnvironmentID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetDeprecatedProviderConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDeprecatedProviderConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDiscoveryProviderConfigSchema invokes get_discovery_provider_config_schema operation.
//
// Get the configuration schema for a specific discovery provider type.
//
// GET /api/v1/discovery/providers/{provider_type}/config-schema
func (c *Client) GetDiscoveryProviderConfigSchema(ctx context.Context, params GetDiscoveryProviderConfigSchemaParams) (GetDiscoveryProviderConfigSchemaRes, error) {
	res, err := c.sendGetDiscoveryProviderConfigSchema(ctx, params)
	return res, err
}

func (c *Client) sendGetDiscoveryProviderConfigSchema(ctx context.Context, params GetDiscoveryProviderConfigSchemaParams) (res GetDiscoveryProviderConfigSchemaRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_discovery_provider_config_schema"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/providers/{provider_type}/config-schema"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetDiscoveryProviderConfigSchemaOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/discovery/providers/"
	{
		// Encode "provider_type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProviderType))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config-schema"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetDiscoveryProviderConfigSchemaOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetDiscoveryProviderConfigSchemaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntities invokes get_entities operation.
//
// Retrieves entities from the ontology, optionally filtered by field selectors. Field selectors use
// dot notation for nested properties (e.g., 'spec.metadata.owner=team-a'). Requires 'read:entities'
// permission.
//
// GET /api/v1/entities/
func (c *Client) GetEntities(ctx context.Context, params GetEntitiesParams) (GetEntitiesRes, error) {
	res, err := c.sendGetEntities(ctx, params)
	return res, err
}

func (c *Client) sendGetEntities(ctx context.Context, params GetEntitiesParams) (res GetEntitiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entities"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entities/"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntitiesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "label" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "label",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Label.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include_relations" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include_relations",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeRelations.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "fieldSelector" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "fieldSelector",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FieldSelector.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntitiesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntitlements invokes get_entitlements operation.
//
// Get all entitlements and current usage for the authenticated user.
//
// GET /api/v1/entitlements
func (c *Client) GetEntitlements(ctx context.Context) (GetEntitlementsRes, error) {
	res, err := c.sendGetEntitlements(ctx)
	return res, err
}

func (c *Client) sendGetEntitlements(ctx context.Context) (res GetEntitlementsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entitlements"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entitlements"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntitlementsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entitlements"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntitlementsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntitlementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntity invokes get_entity operation.
//
// Fetches a specific entity based on group, version, namespace, plural, and name, including related
// entities and relations. Requires 'read:entities' permission.
//
// GET /api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}
func (c *Client) GetEntity(ctx context.Context, params GetEntityParams) (GetEntityRes, error) {
	res, err := c.sendGetEntity(ctx, params)
	return res, err
}

func (c *Client) sendGetEntity(ctx context.Context, params GetEntityParams) (res GetEntityRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entity"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entities/{group}/{version}/{kind}/{namespace}/{name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntityOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [10]string
	pathParts[0] = "/api/v1/entities/"
	{
		// Encode "group" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Group))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "version" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "version",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Version))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "kind" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "kind",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Kind))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/"
	{
		// Encode "namespace" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "namespace",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Namespace))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[7] = encoded
	}
	pathParts[8] = "/"
	{
		// Encode "name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Name))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[9] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityByUID invokes get_entity_by_uid operation.
//
// Fetches a specific entity by its unique identifier (UID), including related entities and relations.
//
//	Requires 'read:entities' permission.
//
// GET /api/v1/entities/uid/{uid}
func (c *Client) GetEntityByUID(ctx context.Context, params GetEntityByUIDParams) (GetEntityByUIDRes, error) {
	res, err := c.sendGetEntityByUID(ctx, params)
	return res, err
}

func (c *Client) sendGetEntityByUID(ctx context.Context, params GetEntityByUIDParams) (res GetEntityByUIDRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entity_by_uid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entities/uid/{uid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntityByUIDOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/entities/uid/"
	{
		// Encode "uid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Namespace.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntityByUIDOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityByUIDResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityDefinitions invokes get_entity_definitions operation.
//
// Fetches a list of all entity definitions with versions, ordered by group and kind.
//
// GET /api/v1/entities/definitions
func (c *Client) GetEntityDefinitions(ctx context.Context) (GetEntityDefinitionsRes, error) {
	res, err := c.sendGetEntityDefinitions(ctx)
	return res, err
}

func (c *Client) sendGetEntityDefinitions(ctx context.Context) (res GetEntityDefinitionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entity_definitions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entities/definitions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntityDefinitionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/definitions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntityDefinitionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityDefinitionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEntityTools invokes get_entity_tools operation.
//
// Get all MCP tools associated with an entity definition.
//
// GET /api/v1/mcp/entity-definitions/{entity_definition_id}/tools
func (c *Client) GetEntityTools(ctx context.Context, params GetEntityToolsParams) (GetEntityToolsRes, error) {
	res, err := c.sendGetEntityTools(ctx, params)
	return res, err
}

func (c *Client) sendGetEntityTools(ctx context.Context, params GetEntityToolsParams) (res GetEntityToolsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_entity_tools"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/mcp/entity-definitions/{entity_definition_id}/tools"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEntityToolsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/mcp/entity-definitions/"
	{
		// Encode "entity_definition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "entity_definition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EntityDefinitionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tools"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "entity_version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "entity_version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EntityVersionID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEntityToolsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEntityToolsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentStatus invokes get_environment_status operation.
//
// Get Environment Status.
//
// GET /api/v1/environments/{env_id}/status
func (c *Client) GetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (GetEnvironmentStatusRes, error) {
	res, err := c.sendGetEnvironmentStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentStatus(ctx context.Context, params GetEnvironmentStatusParams) (res GetEnvironmentStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_environment_status"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/environments/{env_id}/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEnvironmentStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "env_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "env_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEnvironmentStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentUser invokes get_environment_user operation.
//
// Get a specific environment user by ID.
//
// GET /api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) GetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (GetEnvironmentUserRes, error) {
	res, err := c.sendGetEnvironmentUser(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentUser(ctx context.Context, params GetEnvironmentUserParams) (res GetEnvironmentUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_environment_user"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/{user_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEnvironmentUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironments invokes get_environments operation.
//
// List all environments accessible to the authenticated user.
//
// GET /api/v1/environments
func (c *Client) GetEnvironments(ctx context.Context) (GetEnvironmentsRes, error) {
	res, err := c.sendGetEnvironments(ctx)
	return res, err
}

func (c *Client) sendGetEnvironments(ctx context.Context) (res GetEnvironmentsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_environments"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/environments"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetEnvironmentsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetEnvironmentsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetEnvironmentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpEndpointEntityTypes invokes get_mcp_endpoint_entity_types operation.
//
// Get all entity types associated with an MCP endpoint's tools.
//
// GET /api/v1/mcp/endpoints/{mcpendpoint_name}/entity-types
func (c *Client) GetMcpEndpointEntityTypes(ctx context.Context, params GetMcpEndpointEntityTypesParams) (GetMcpEndpointEntityTypesRes, error) {
	res, err := c.sendGetMcpEndpointEntityTypes(ctx, params)
	return res, err
}

func (c *Client) sendGetMcpEndpointEntityTypes(ctx context.Context, params GetMcpEndpointEntityTypesParams) (res GetMcpEndpointEntityTypesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_mcp_endpoint_entity_types"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints/{mcpendpoint_name}/entity-types"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMcpEndpointEntityTypesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/mcp/endpoints/"
	{
		// Encode "mcpendpoint_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.McpendpointName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/entity-types"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "tool_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tool_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ToolName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetMcpEndpointEntityTypesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMcpEndpointEntityTypesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpendpoint invokes get_mcpendpoint operation.
//
// Get a specific MCP endpoint configuration by ID.
//
// GET /api/v1/mcp/endpoints/{mcpendpoint_id}
func (c *Client) GetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (GetMcpendpointRes, error) {
	res, err := c.sendGetMcpendpoint(ctx, params)
	return res, err
}

func (c *Client) sendGetMcpendpoint(ctx context.Context, params GetMcpendpointParams) (res GetMcpendpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_mcpendpoint"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints/{mcpendpoint_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMcpendpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/mcp/endpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMcpendpoints invokes get_mcpendpoints operation.
//
// List all MCP endpoint configurations for the authenticated user and environment.
//
// GET /api/v1/mcp/endpoints
func (c *Client) GetMcpendpoints(ctx context.Context) (GetMcpendpointsRes, error) {
	res, err := c.sendGetMcpendpoints(ctx)
	return res, err
}

func (c *Client) sendGetMcpendpoints(ctx context.Context) (res GetMcpendpointsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_mcpendpoints"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetMcpendpointsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/mcp/endpoints"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetMcpendpointsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetMcpendpointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModel invokes get_model operation.
//
// Retrieve a specific AI model configuration by name.
//
// GET /api/v1/models/{model_name}
func (c *Client) GetModel(ctx context.Context, params GetModelParams) (GetModelRes, error) {
	res, err := c.sendGetModel(ctx, params)
	return res, err
}

func (c *Client) sendGetModel(ctx context.Context, params GetModelParams) (res GetModelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_model"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/models/{model_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetModelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/"
	{
		// Encode "model_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModelprovider invokes get_modelprovider operation.
//
// Get a specific model provider configuration by ID.
//
// GET /api/v1/models/providers/{provider_id}
func (c *Client) GetModelprovider(ctx context.Context, params GetModelproviderParams) (GetModelproviderRes, error) {
	res, err := c.sendGetModelprovider(ctx, params)
	return res, err
}

func (c *Client) sendGetModelprovider(ctx context.Context, params GetModelproviderParams) (res GetModelproviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_modelprovider"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/models/providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetModelproviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModelproviders invokes get_modelproviders operation.
//
// List all model provider configurations for the authenticated user and environment.
//
// GET /api/v1/models/providers
func (c *Client) GetModelproviders(ctx context.Context) (GetModelprovidersRes, error) {
	res, err := c.sendGetModelproviders(ctx)
	return res, err
}

func (c *Client) sendGetModelproviders(ctx context.Context) (res GetModelprovidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_modelproviders"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/models/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetModelprovidersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/models/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelprovidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetModelprovidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetModels invokes get_models operation.
//
// Retrieve all AI model configurations for the current environment.
//
// GET /api/v1/models
func (c *Client) GetModels(ctx context.Context) (GetModelsRes, error) {
	res, err := c.sendGetModels(ctx)
	return res, err
}

func (c *Client) sendGetModels(ctx context.Context) (res GetModelsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_models"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/models"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetModelsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/models"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetModelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetModelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOAuthAuthorizationURL invokes get_oauth_authorization_url operation.
//
// Generate an OAuth authorization URL for a service.
//
// POST /api/v1/oauth/authorize
func (c *Client) GetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (GetOAuthAuthorizationURLRes, error) {
	res, err := c.sendGetOAuthAuthorizationURL(ctx, request)
	return res, err
}

func (c *Client) sendGetOAuthAuthorizationURL(ctx context.Context, request *OAuthAuthorizationRequest) (res GetOAuthAuthorizationURLRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_oauth_authorization_url"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/oauth/authorize"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOAuthAuthorizationURLOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetOAuthAuthorizationURLRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetOAuthAuthorizationURLOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOAuthAuthorizationURLResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOAuthService invokes get_oauth_service operation.
//
// Get a specific OAuth service configuration by ID.
//
// GET /api/v1/oauth/services/{service_id}
func (c *Client) GetOAuthService(ctx context.Context, params GetOAuthServiceParams) (GetOAuthServiceRes, error) {
	res, err := c.sendGetOAuthService(ctx, params)
	return res, err
}

func (c *Client) sendGetOAuthService(ctx context.Context, params GetOAuthServiceParams) (res GetOAuthServiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_oauth_service"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/oauth/services/{service_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOAuthServiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPendingInvitations invokes get_pending_invitations operation.
//
// Get all pending invitations for an environment.
//
// GET /api/v1/environments/{environment_id}/users/pending
func (c *Client) GetPendingInvitations(ctx context.Context, params GetPendingInvitationsParams) (GetPendingInvitationsRes, error) {
	res, err := c.sendGetPendingInvitations(ctx, params)
	return res, err
}

func (c *Client) sendGetPendingInvitations(ctx context.Context, params GetPendingInvitationsParams) (res GetPendingInvitationsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_pending_invitations"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/pending"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPendingInvitationsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/pending"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetPendingInvitationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPendingInvitationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPrompt invokes get_prompt operation.
//
// Retrieve a specific prompt template by ID.
//
// GET /api/v1/prompts/{prompt_id}
func (c *Client) GetPrompt(ctx context.Context, params GetPromptParams) (GetPromptRes, error) {
	res, err := c.sendGetPrompt(ctx, params)
	return res, err
}

func (c *Client) sendGetPrompt(ctx context.Context, params GetPromptParams) (res GetPromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_prompt"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/prompts/{prompt_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetPromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/prompts/"
	{
		// Encode "prompt_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PromptID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetPromptOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetPromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSubscriptions invokes get_subscriptions operation.
//
// List all subscriptions for the authenticated user.
//
// GET /api/v1/subscriptions
func (c *Client) GetSubscriptions(ctx context.Context) (GetSubscriptionsRes, error) {
	res, err := c.sendGetSubscriptions(ctx)
	return res, err
}

func (c *Client) sendGetSubscriptions(ctx context.Context) (res GetSubscriptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_subscriptions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/subscriptions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSubscriptionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSystemDefaultPrompt invokes get_system_default_prompt operation.
//
// Retrieve the system default prompt template.
//
// GET /api/v1/prompts/system-default
func (c *Client) GetSystemDefaultPrompt(ctx context.Context) (GetSystemDefaultPromptRes, error) {
	res, err := c.sendGetSystemDefaultPrompt(ctx)
	return res, err
}

func (c *Client) sendGetSystemDefaultPrompt(ctx context.Context) (res GetSystemDefaultPromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_system_default_prompt"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/prompts/system-default"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetSystemDefaultPromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/prompts/system-default"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetSystemDefaultPromptOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetSystemDefaultPromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTokens invokes get_tokens operation.
//
// List all API tokens for the authenticated user.
//
// GET /api/v1/tokens
func (c *Client) GetTokens(ctx context.Context) (GetTokensRes, error) {
	res, err := c.sendGetTokens(ctx)
	return res, err
}

func (c *Client) sendGetTokens(ctx context.Context) (res GetTokensRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("get_tokens"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/tokens"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTokensOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, GetTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InviteEnvironmentUser invokes invite_environment_user operation.
//
// Invite a user to an environment.
//
// POST /api/v1/environments/{environment_id}/users/invite
func (c *Client) InviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (InviteEnvironmentUserRes, error) {
	res, err := c.sendInviteEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendInviteEnvironmentUser(ctx context.Context, request *EnvironmentUserInvite, params InviteEnvironmentUserParams) (res InviteEnvironmentUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("invite_environment_user"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/invite"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InviteEnvironmentUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/invite"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInviteEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, InviteEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInviteEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListChatSuggestions invokes list_chat_suggestions operation.
//
// List chat suggestions including system-wide and user-specific ones.
//
// GET /api/v1/chats/suggestions
func (c *Client) ListChatSuggestions(ctx context.Context, params ListChatSuggestionsParams) (ListChatSuggestionsRes, error) {
	res, err := c.sendListChatSuggestions(ctx, params)
	return res, err
}

func (c *Client) sendListChatSuggestions(ctx context.Context, params ListChatSuggestionsParams) (res ListChatSuggestionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_chat_suggestions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/chats/suggestions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListChatSuggestionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/chats/suggestions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "active_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "active_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ActiveOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListChatSuggestionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListChatSuggestionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConfiguredProviders invokes list_configured_providers operation.
//
// List all configured discovery providers for the current environment.
// Secrets in provider configurations are masked.
//
// GET /api/v1/discovery/configured-providers
func (c *Client) ListConfiguredProviders(ctx context.Context) (ListConfiguredProvidersRes, error) {
	res, err := c.sendListConfiguredProviders(ctx)
	return res, err
}

func (c *Client) sendListConfiguredProviders(ctx context.Context) (res ListConfiguredProvidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_configured_providers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/configured-providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListConfiguredProvidersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/configured-providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListConfiguredProvidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListConfiguredProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListDiscoveryProviders invokes list_discovery_providers operation.
//
// List all available discovery provider types with their configuration schemas.
//
// GET /api/v1/discovery/providers
func (c *Client) ListDiscoveryProviders(ctx context.Context) (ListDiscoveryProvidersRes, error) {
	res, err := c.sendListDiscoveryProviders(ctx)
	return res, err
}

func (c *Client) sendListDiscoveryProviders(ctx context.Context) (res ListDiscoveryProvidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_discovery_providers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/discovery/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListDiscoveryProvidersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListDiscoveryProvidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListDiscoveryProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListEnvironmentUsers invokes list_environment_users operation.
//
// List all users in an environment.
//
// GET /api/v1/environments/{environment_id}/users
func (c *Client) ListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (ListEnvironmentUsersRes, error) {
	res, err := c.sendListEnvironmentUsers(ctx, params)
	return res, err
}

func (c *Client) sendListEnvironmentUsers(ctx context.Context, params ListEnvironmentUsersParams) (res ListEnvironmentUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_environment_users"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListEnvironmentUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListEnvironmentUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListEnvironmentUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListMcpendpointTools invokes list_mcpendpoint_tools operation.
//
// List all available tools from a specific MCP endpoint.
//
// GET /api/v1/mcp/endpoints/{mcpendpoint_id}/tools
func (c *Client) ListMcpendpointTools(ctx context.Context, params ListMcpendpointToolsParams) (ListMcpendpointToolsRes, error) {
	res, err := c.sendListMcpendpointTools(ctx, params)
	return res, err
}

func (c *Client) sendListMcpendpointTools(ctx context.Context, params ListMcpendpointToolsParams) (res ListMcpendpointToolsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_mcpendpoint_tools"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints/{mcpendpoint_id}/tools"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListMcpendpointToolsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/mcp/endpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tools"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListMcpendpointToolsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListMcpendpointToolsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOAuthServices invokes list_oauth_services operation.
//
// List all OAuth service configurations.
//
// GET /api/v1/oauth/services
func (c *Client) ListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (ListOAuthServicesRes, error) {
	res, err := c.sendListOAuthServices(ctx, params)
	return res, err
}

func (c *Client) sendListOAuthServices(ctx context.Context, params ListOAuthServicesParams) (res ListOAuthServicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_oauth_services"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/oauth/services"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListOAuthServicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/services"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "active_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "active_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ActiveOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListOAuthServicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOAuthServicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOAuthTokens invokes list_oauth_tokens operation.
//
// List all OAuth tokens for the authenticated user.
//
// GET /api/v1/oauth/tokens
func (c *Client) ListOAuthTokens(ctx context.Context) (ListOAuthTokensRes, error) {
	res, err := c.sendListOAuthTokens(ctx)
	return res, err
}

func (c *Client) sendListOAuthTokens(ctx context.Context) (res ListOAuthTokensRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_oauth_tokens"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/oauth/tokens"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListOAuthTokensOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/oauth/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListOAuthTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOAuthTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListOrphanedEntities invokes list_orphaned_entities operation.
//
// Lists all entities marked as orphans across all namespaces. Requires 'read:entities' permission.
//
// GET /api/v1/entities/orphans
func (c *Client) ListOrphanedEntities(ctx context.Context, params ListOrphanedEntitiesParams) (ListOrphanedEntitiesRes, error) {
	res, err := c.sendListOrphanedEntities(ctx, params)
	return res, err
}

func (c *Client) sendListOrphanedEntities(ctx context.Context, params ListOrphanedEntitiesParams) (res ListOrphanedEntitiesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_orphaned_entities"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/entities/orphans"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListOrphanedEntitiesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/entities/orphans"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "namespace" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "namespace",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Namespace.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListOrphanedEntitiesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListOrphanedEntitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListPrompts invokes list_prompts operation.
//
// List all prompt templates for the environment, optionally filtered by active status.
//
// GET /api/v1/prompts
func (c *Client) ListPrompts(ctx context.Context, params ListPromptsParams) (ListPromptsRes, error) {
	res, err := c.sendListPrompts(ctx, params)
	return res, err
}

func (c *Client) sendListPrompts(ctx context.Context, params ListPromptsParams) (res ListPromptsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("list_prompts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/v1/prompts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListPromptsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/prompts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "active" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "active",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Active.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, ListPromptsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListPromptsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrateAllDeprecatedConfigs invokes migrate_all_deprecated_configs operation.
//
// Batch migrate all configs using deprecated versions.
//
// POST /api/v1/discovery/versions/migrate-all
func (c *Client) MigrateAllDeprecatedConfigs(ctx context.Context, params MigrateAllDeprecatedConfigsParams) (MigrateAllDeprecatedConfigsRes, error) {
	res, err := c.sendMigrateAllDeprecatedConfigs(ctx, params)
	return res, err
}

func (c *Client) sendMigrateAllDeprecatedConfigs(ctx context.Context, params MigrateAllDeprecatedConfigsParams) (res MigrateAllDeprecatedConfigsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrate_all_deprecated_configs"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/discovery/versions/migrate-all"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MigrateAllDeprecatedConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/api/v1/discovery/versions/migrate-all"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "environment_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "environment_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.EnvironmentID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, MigrateAllDeprecatedConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrateAllDeprecatedConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MigrateProviderConfig invokes migrate_provider_config operation.
//
// Migrate a specific provider config to the latest version.
//
// POST /api/v1/discovery/versions/{provider_id}/migrate
func (c *Client) MigrateProviderConfig(ctx context.Context, params MigrateProviderConfigParams) (MigrateProviderConfigRes, error) {
	res, err := c.sendMigrateProviderConfig(ctx, params)
	return res, err
}

func (c *Client) sendMigrateProviderConfig(ctx context.Context, params MigrateProviderConfigParams) (res MigrateProviderConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("migrate_provider_config"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/discovery/versions/{provider_id}/migrate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, MigrateProviderConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/discovery/versions/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/migrate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, MigrateProviderConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeMigrateProviderConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostChatMessages invokes post_chat_messages operation.
//
// Add one or more messages to a chat session.
//
// POST /api/v1/chats/{chat_id}/messages
func (c *Client) PostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (PostChatMessagesRes, error) {
	res, err := c.sendPostChatMessages(ctx, request, params)
	return res, err
}

func (c *Client) sendPostChatMessages(ctx context.Context, request []ChatMessageCreate, params PostChatMessagesParams) (res PostChatMessagesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("post_chat_messages"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/v1/chats/{chat_id}/messages"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PostChatMessagesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/api/v1/chats/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostChatMessagesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, PostChatMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePostChatMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeOAuthToken invokes revoke_oauth_token operation.
//
// Revoke an OAuth token for a service.
//
// DELETE /api/v1/oauth/tokens/{service_name}
func (c *Client) RevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (RevokeOAuthTokenRes, error) {
	res, err := c.sendRevokeOAuthToken(ctx, params)
	return res, err
}

func (c *Client) sendRevokeOAuthToken(ctx context.Context, params RevokeOAuthTokenParams) (res RevokeOAuthTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("revoke_oauth_token"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/v1/oauth/tokens/{service_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RevokeOAuthTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/tokens/"
	{
		// Encode "service_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServiceName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, RevokeOAuthTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeRevokeOAuthTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateChat invokes update_chat operation.
//
// Update an existing chat session.
//
// PUT /api/v1/chats/{chat_id}
func (c *Client) UpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (UpdateChatRes, error) {
	res, err := c.sendUpdateChat(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateChat(ctx context.Context, request *ChatSessionUpdate, params UpdateChatParams) (res UpdateChatRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_chat"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/chats/{chat_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateChatOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/chats/"
	{
		// Encode "chat_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "chat_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ChatID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateChatRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateChatOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateChatResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateConfiguredProvider invokes update_configured_provider operation.
//
// Update a configured discovery provider.
// Only provided fields will be updated. To update secrets, provide the full
// config object with new secret values.
//
// PUT /api/v1/discovery/configured-providers/{provider_id}
func (c *Client) UpdateConfiguredProvider(ctx context.Context, request *ConfiguredProviderUpdate, params UpdateConfiguredProviderParams) (UpdateConfiguredProviderRes, error) {
	res, err := c.sendUpdateConfiguredProvider(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateConfiguredProvider(ctx context.Context, request *ConfiguredProviderUpdate, params UpdateConfiguredProviderParams) (res UpdateConfiguredProviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_configured_provider"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/discovery/configured-providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateConfiguredProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/discovery/configured-providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateConfiguredProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateConfiguredProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateConfiguredProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEnvironmentUser invokes update_environment_user operation.
//
// Update an environment user's role.
//
// PUT /api/v1/environments/{environment_id}/users/{user_id}
func (c *Client) UpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (UpdateEnvironmentUserRes, error) {
	res, err := c.sendUpdateEnvironmentUser(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEnvironmentUser(ctx context.Context, request *EnvironmentUserUpdate, params UpdateEnvironmentUserParams) (res UpdateEnvironmentUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_environment_user"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/environments/{environment_id}/users/{user_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateEnvironmentUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/api/v1/environments/"
	{
		// Encode "environment_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environment_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.EnvironmentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEnvironmentUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateEnvironmentUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateEnvironmentUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateMcpendpoint invokes update_mcpendpoint operation.
//
// Update a specific MCP endpoint configuration by ID.
//
// PUT /api/v1/mcp/endpoints/{mcpendpoint_id}
func (c *Client) UpdateMcpendpoint(ctx context.Context, request *MCPEndpointUpdate, params UpdateMcpendpointParams) (UpdateMcpendpointRes, error) {
	res, err := c.sendUpdateMcpendpoint(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateMcpendpoint(ctx context.Context, request *MCPEndpointUpdate, params UpdateMcpendpointParams) (res UpdateMcpendpointRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_mcpendpoint"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/mcp/endpoints/{mcpendpoint_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateMcpendpointOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/mcp/endpoints/"
	{
		// Encode "mcpendpoint_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "mcpendpoint_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.McpendpointID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateMcpendpointRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateMcpendpointOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateMcpendpointResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateModel invokes update_model operation.
//
// Update an existing AI model configuration by name.
//
// PUT /api/v1/models/{model_name}
func (c *Client) UpdateModel(ctx context.Context, request *ModelUpdate, params UpdateModelParams) (UpdateModelRes, error) {
	res, err := c.sendUpdateModel(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateModel(ctx context.Context, request *ModelUpdate, params UpdateModelParams) (res UpdateModelRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_model"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/models/{model_name}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateModelOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/"
	{
		// Encode "model_name" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "model_name",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ModelName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateModelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateModelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateModelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateModelprovider invokes update_modelprovider operation.
//
// Update a specific model provider configuration by ID.
//
// PUT /api/v1/models/providers/{provider_id}
func (c *Client) UpdateModelprovider(ctx context.Context, request *ModelProviderUpdate, params UpdateModelproviderParams) (UpdateModelproviderRes, error) {
	res, err := c.sendUpdateModelprovider(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateModelprovider(ctx context.Context, request *ModelProviderUpdate, params UpdateModelproviderParams) (res UpdateModelproviderRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_modelprovider"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/models/providers/{provider_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateModelproviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/models/providers/"
	{
		// Encode "provider_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ProviderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateModelproviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateModelproviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateModelproviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateOAuthService invokes update_oauth_service operation.
//
// Update an existing OAuth service configuration.
//
// PUT /api/v1/oauth/services/{service_id}
func (c *Client) UpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (UpdateOAuthServiceRes, error) {
	res, err := c.sendUpdateOAuthService(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateOAuthService(ctx context.Context, request *OAuthServiceUpdate, params UpdateOAuthServiceParams) (res UpdateOAuthServiceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_oauth_service"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/oauth/services/{service_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateOAuthServiceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/oauth/services/"
	{
		// Encode "service_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServiceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateOAuthServiceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateOAuthServiceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateOAuthServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePrompt invokes update_prompt operation.
//
// Update an existing prompt template by ID.
//
// PUT /api/v1/prompts/{prompt_id}
func (c *Client) UpdatePrompt(ctx context.Context, request *PromptUpdate, params UpdatePromptParams) (UpdatePromptRes, error) {
	res, err := c.sendUpdatePrompt(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePrompt(ctx context.Context, request *PromptUpdate, params UpdatePromptParams) (res UpdatePromptRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_prompt"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/prompts/{prompt_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdatePromptOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/prompts/"
	{
		// Encode "prompt_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "prompt_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PromptID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePromptRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdatePromptOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdatePromptResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateToken invokes update_token operation.
//
// Update an existing API token.
//
// PUT /api/v1/tokens/{token_id}
func (c *Client) UpdateToken(ctx context.Context, request *ApiTokenUpdate, params UpdateTokenParams) (UpdateTokenRes, error) {
	res, err := c.sendUpdateToken(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateToken(ctx context.Context, request *ApiTokenUpdate, params UpdateTokenParams) (res UpdateTokenRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("update_token"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.URLTemplateKey.String("/api/v1/tokens/{token_id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UpdateTokenOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/api/v1/tokens/"
	{
		// Encode "token_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "token_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateTokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:OAuth2PasswordBearer"
			switch err := c.securityOAuth2PasswordBearer(ctx, UpdateTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2PasswordBearer\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUpdateTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
